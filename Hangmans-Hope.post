;;;;;
title: Hangman's Hope
tags: LISP, Programming
date: 2008-10-17 08:02:04
format: html
;;;;;
The last week has been really, really hard. Mostly because I've been confronted with something I hoped wouldn't have to happen: The necessity of returning to academia. I've applied to a few more jobs and we'll see what happens there. I got turned down by King &amp; Spalding in a letter today and am going to call tomorrow and ask why. I'm really just not getting enough done on my own to justify being out of school. I'm not learning enough. Perhaps I do need the structure. I'm disappointed but I have to re-evaluate based on my experience. State changes and given my present state I'm looking at returning to SPSU in the Spring or Fall of next of year. There's some notion of transferring to GA Tech as well but I'm not sure what I think about that.<br><br>One nice thing about SPSU would be that I'd at least have the spare time to continue pursuing LISP and other personal studies. It's also worth noting that a significant motivation in this year off was to at least get the fundamental concepts of programming down some before being buried in the specifics of the monstrous languages used to instruct most Freshman in Computer Science these days (i.e. Java; pythonistas at Tech, you're lucky).<br><br>Anyway, tonight I was frustrated with the fact that I hadn't written any code in a long time and I hadn't written a real program of my own in an even longer time. For one reason or another, implementing Hangman in Common Lisp seemed like a good idea. Now, I'm not claiming that hangman is ever any great feat...except maybe if you write it in <a href="http://en.wikipedia.org/wiki/Brainfuck">BrainFuck</a>. Nor is it any great feat to write it in under a hundred lines. Worse still is that it lacks any ASCII art. That said, I did this in a few hours, found it pretty fun and think it came out fairly readable and concise in the end. After all, how couldn't it? It's hangman.<br><br><pre lang="lisp"><br>;; Hangman<br>;; Brit Butler <redline6561@gmail.com><br>;; v.01<br>;; Feature Ideas: ASCII hangman. Eliminate explicit elt references and other hackish<br>;; stuff, especially show-letter. Import dictionary in place of *word-list*.<br><br>(defparameter *word-list* '("cookies" "kittens" "fairies"<br>			    "unicorns" "words" "linux"<br>			    "lisp" "music" "songs"<br>			    "sex" "love" "fun"<br>			    "code" "cease" "and"<br>			    "desist" "read" "print"<br>			    "eval" "loop" "macro"))<br><br>(defparameter *turn-count* '())<br>(defparameter *letters-picked* '())<br>(defparameter *word-in-progress* '())<br>(defparameter *solved-word* '())<br><br>(defun hangman ()<br>  (setf *turn-count* 7)<br>  (setf *letters-picked* '())<br>  (select-game-type)<br>  (work-on-word))<br><br>(defun select-game-type ()<br>  (if (y-or-n-p "Would you prefer to have a word chosen at random?")<br>      (set-the-words (elt *word-list* (random (length *word-list*))))<br>      (set-the-words (string-downcase (read-prompt "Please input your desired word: ")))))<br><br>(defun set-the-words (word-of-the-run)<br>  (setf *solved-word* word-of-the-run)<br>  (setf *word-in-progress* (make-array (length word-of-the-run)<br>                                       :initial-element #\- :element-type 'character))<br>  (format t "~a~%" *word-in-progress*))<br><br>(defun read-prompt (query-string)<br>  (format *query-io* query-string)<br>  (read-line *query-io*))<br><br>(defun check-letter (letter)<br>  (if (already-picked? letter)<br>      (format t "You already picked that goofball! Try again...~%")<br>      (push letter *letters-picked*))<br>  (cond ((is-in-word? letter) (show-letter letter))<br>	((not (is-in-word? letter)) (decf *turn-count*)<br>	 (format t "Nope. Not in there. ~a turns left.~%" *turn-count*))))<br><br>(defun is-in-word? (letter &key (start 0))<br>  (position letter *solved-word* :start start))<br><br>(defun already-picked? (letter)<br>  (position letter *letters-picked*))<br><br>(defun show-letter (letter)<br>  (setf (elt *word-in-progress* (is-in-word? letter)) letter)<br>  (format t "~a~%" *word-in-progress*))<br><br>(defun pick-a-letter (&key (message "Pick a letter please: "))<br>  (let ((rtn (read-prompt message)))<br>    (if (> (length rtn) 1)<br>	(pick-a-letter<br>          :message "We only need ONE letter thank you very much. Try again: ")<br>	(check-letter (elt rtn 0)))))<br><br>(defun work-on-word ()<br>  (pick-a-letter)<br>  (word-finished?))<br><br>(defun word-finished? ()<br>  (if (= *turn-count* 0)<br>      (game-over)<br>  (if (string= *solved-word* *word-in-progress*)<br>      (play-again? "Congratulations.")<br>      (work-on-word))))<br><br>(defun game-over ()<br>  (format t "Sorry. The word was ~a.~%" *solved-word*)<br>  (play-again? "You're all out of turns. Game over."))<br><br>(defun play-again? (message)<br>  (format t "~a~%" message)<br>  (if (y-or-n-p "Would you like to play again?")<br>      (hangman)<br>      (format t "Thanks for playing!~%")))<br></pre>
