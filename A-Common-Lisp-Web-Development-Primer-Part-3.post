;;;;;
title: A Common Lisp Web Development Primer, Part 3
tags: LISP, Programming
date: 2010-11-22 04:24:03
format: html
;;;;;
<strong>Disclaimer</strong>: What? You haven't already read the first two parts? Feel free to go ahead and do that. The same disclaimers apply. (require '<a href="http:///&">cl-wdp-part1</a> '<a href="http:///&">cl-wdp-part2</a>)<br><br><h3>Today's Topics</h3><br>The main topics we'll be covering are Weblocks widgets, forms and views along with a brief example of creating a presentation to use jQueryUI's <a href="http://jqueryui.com/demos/datepicker/#inline">Datepicker</a>. There will also be a brief aside on what to do after an emergency reboot or power outage relating to cl-prevalence and trivial-timers. By the end the <a href="http://clockwork.redlinernotes.com/">clockwork site</a> will be fully functional.<br><br><h3>Form-widgets, Widgets and Views</h3><br>The User Guide has pretty nice expository summaries of <a href="http://viridian-project.de/~sky/user-guide.stx.html#Widgets">Widgets</a> and <a href="http://viridian-project.de/~sky/user-guide.stx.html#Views">Views</a>. The bottom line is that Widgets are what Weblocks pages are composed of and views are different ways to render those widgets. A macro called <a href="http://viridian-project.de/~sky/weblocks-stable/docs/gen/weblocks-package/macro-defwidget.html">defwidget</a> is used to construct widgets which are just new classes which inherit from the widget-metaclass. Don't worry if you don't know what that means. Essentially, you define widgets for the data you care about working with and then you define views to render that data, whether as a form for editing, a table for comparing multiple items or some other representation.<br><br>Leslie has been working on some new <a href="http://bitbucket.org/S11001001/weblocks-dev/src/1efb9f404367/contrib/lpolzer/form-widget.lisp">form-widget</a> code intended to <a href="http://groups.google.com/group/weblocks/browse_thread/thread/ac89bf70b29f625c#">remove some of the sharp edges of the current system</a>. As this site is basically just a form it made sense for me to try to use this new code (and Leslie wanted me to help him bang on it). Consequently, one thing you'll need to do is add (load "/path/to/weblocks/contrib/lpolzer/form-widget.lisp") to your init.lisp file that runs on startup. It should be placed after weblocks is loaded and before the loading of clockwork.<br><br>Last time we defined a reminder class with slots for the data we really care about: a list of emails, a title and summary and timestamps for when to send that message and when the event itself occurs. However, it won't do to ask our users to input timestamps or to tell us the "email" for their cell phone's SMS gateway. To that end, we'll define a view to gather the information we really need to construct the timestamps and other parts of the reminder. We need to know whether they want to be notified by email, text message or both. We'll need the corresponding contact info, including their cell carrier if they want to be notified by text message. We'll also need to note the event date, timezone and time as well as how long before the event they'd like to be reminded and a message and title. I've also thrown in a "honeypot" field. In theory, spam bots will indiscriminately fill it so we won't get any bogus submissions because the form won't validate. Maybe later we'll replace this with reCaptchas.<br><br>So let's get to it and define a view for our form in a new file src/forms.lisp. Insert the following code:<br><pre lang="lisp"><br>(in-package :clockwork)<br><br>(defview reminder-form-view (:type form :caption "Schedule an Event Reminder..."<br>			     :buttons '((:submit . "Submit")) :persistp nil)<br>  (send-as :present-as (dropdown :choices '(("An email and a text." . :both)<br>					    ("Just an e-mail." . :email)<br>					    ("Just a text." . :text))<br>				 :welcome-name "How to send it")<br>	   :requiredp t)<br>  (email :satisfies 'valid-email)<br>  (cell-number :satisfies 'valid-cell-number)<br>  (cell-carrier :present-as (dropdown :choices *sms-gateways*))<br>  (event-date :present-as (calendar) :requiredp t)<br>  (event-hour :present-as (dropdown :choices *hour-choices*)<br>	      :requiredp t)<br>  (event-minute :present-as (dropdown :choices   '(("00" . 0)<br>						   ("15" . 15)<br>						   ("30" . 30)<br>						   ("45" . 45)))<br>		:requiredp t)<br>  (timezone :present-as (dropdown :choices *timezones*)<br>	    :requiredp t)<br>  (remind-me :present-as (dropdown :choices '(("At the event" . 0)<br>					      ("5 minutes before" . 300)<br>					      ("10 minutes before" . 600)<br>					      ("15 minutes before" . 900)<br>					      ("30 minutes before" . 1800)<br>					      ("45 minutes before" . 2700)<br>					      ("1 hour before" . 3600)<br>					      ("2 hours before" . 7200)<br>					      ("1 day before" . 86400)<br>					      ("2 days before" . 172800)<br>					      ("1 week before" . 604800)<br>					      ("2 weeks before" . 1209600)))<br>	     :requiredp t)<br>  (subject :requiredp t)<br>  (summary :present-as (textarea :rows 5))<br>  (honeypot :label "Leave this blank" :satisfies #'null))<br><br>(defparameter *timezones*<br>  '(("UTC-12:00 (Eniwetok, Kwajalein)" . -43200)<br>    ("UTC-11:00 (Midway Island, Samoa)" . -39600)<br>    ("UTC-10:00 (Hawaii)" . -36000)<br>    ("UTC-09:00 (Alaska)" . -32400)<br>    ("UTC-08:00 (Pacific Time)" . -28800)<br>    ("UTC-07:00 (Mountain Time)" . -25200)<br>    ("UTC-06:00 (Central Time)" . -21600)<br>    ("UTC-05:00 (Eastern Time)" . -18000)<br>    ("UTC-04:00 (Atlantic Time, Caracas)" . -14400)<br>    ("UTC-03:30 (Newfoundland)" . -12600)<br>    ("UTC-03:00 (Brazil, Buenos Aires, Georgetown)" . -10800)<br>    ("UTC-02:00 (Mid-Atlantic)" . -7200)<br>    ("UTC-01:00 (Azores, Cape Verde Islands)" . -3600)<br>    ("UTC+00:00 (Lisbon, London, Casablanca)" . 0)<br>    ("UTC+01:00 (Berlin, Brussels, Copenhagen, Madrid, Paris)" . 3600)<br>    ("UTC+02:00 (Kaliningrad, South Africa)" . 7200)<br>    ("UTC+03:00 (Baghdad, Moscow, Riyadh, St. Petersburg)" . 10800)<br>    ("UTC+03:30 (Tehran)" . 12600)<br>    ("UTC+04:00 (Abu Dhabi, Baku, Muscat, Tbilisi)" . 14400)<br>    ("UTC+04:30 (Kabul)" . 16200)<br>    ("UTC+05:00 (Ekaterinburg, Islamabad, Karachi, Tashkent)" . 18000)<br>    ("UTC+05:30 (Bombay, Calcutta, Madras, New Delhi)" . 19800)<br>    ("UTC+05:45 (Kathmandu)" . 20700)<br>    ("UTC+06:00 (Almaty, Colombo, Dhaka)" . 21600)<br>    ("UTC+07:00 (Bangkok, Hanoi, Jakarta)" . 25200)<br>    ("UTC+08:00 (Beijing, Hong Kong, Perth, Singapore)" . 28800)<br>    ("UTC+09:00 (Osaka, Seoul, Sapporo, Tokyo, Yakutsk)" . 32400)<br>    ("UTC+09:30 (Adelaide, Darwin)" . 34200)<br>    ("UTC+10:00 (Eastern Australia, Guam, Vladivostok)" . 36000)<br>    ("UTC+11:00 (Magadan, New Caledonia, Solomon Islands)" . 39600)<br>    ("UTC+12:00 (Auckland, Fiji, Kamchatka, Wellington)". 43200)))<br><br>(defparameter *hour-choices*<br>  (loop for i from 0 to 23<br>     collecting `(,(format nil "~d" i) . ,i)))<br></pre><br>So here we're defining a view called reminder-form-view and passing in a list of arguments *about* the view as well as a list of fields in the view. In the list of arguments about the view we note that it's a form and we don't want to persist the form contents directly. We use a variety of keywords in the list of form fields to get the behavior we want including :present-as, :requiredp, :satisfies and :label. Present-as allows us to make something a dropdown or any other defined presentation. Note that some presentations do take arguments. Dropdown in particular takes a list of dotted pairs representing the Dropdown choice and it's corresponding value. Requiredp does what you'd expect and marks a form field as required. Satisfies takes a lambda or the name of a function which will validate the field's data. By default, the view will "humanize" the field names and use those humanized names as labels. If you want a different label for some reason, you can achieve that with the :label keyword.<br><br>Now we have a form that takes all the data we need to construct a reminder but we still need to validate the emails and cell phone numbers. Additionally, we'll need to write helper functions to construct the email list and timestamps that the reminder's emails and timestamp slots will be set to. Consequently, add this code to the bottom of the file:<br><br><pre lang="lisp"><br>(defun valid-email (user-input)<br>  "Ensure that there is an @ and a . and input not containing @s before and after each."<br>  (or (cl-ppcre:scan "^[^@]+@[^@]+\\.[^@]+$" user-input)<br>      (values nil "Your email must have an @, a . and text before and after both.")))<br><br>(defun valid-cell-number (user-input)<br>  "Ensure that only numbers are given and there are at least 10."<br>  (or (cl-ppcre:scan "^[0-9]{10,}$" user-input)<br>      (values nil "Your number must have only numbers and at least 10 of them.")))<br><br>(defun get-emails (form-data)<br>  (with-form-values (send-as email cell-number cell-carrier) form-data<br>    (let ((sms-mail (concatenate 'string cell-number "@" cell-carrier)))<br>      ;; this was an ecase with keywords but weblocks converts<br>      ;; the keywords to strings somewhere in form submission<br>      (cond ((string= send-as "BOTH") (list email sms-mail))<br>	    ((string= send-as "EMAIL") (list email))<br>	    ((string= send-as "TEXT") (list sms-mail))))))<br><br>(defun get-timestamps (form-data)<br>  (with-form-values (event-date event-hour event-minute<br>		     remind-me timezone) form-data<br>    (let* ((hour (parse-integer event-hour))<br>	   (minute (parse-integer event-minute))<br>	   (reminder-time-period (parse-integer remind-me))<br>	   (timezone (parse-integer timezone))<br>	   (datestring (split-sequence #\- event-date))<br>	   (day (parse-integer (first datestring)))<br>	   (month (parse-integer (second datestring)))<br>	   (year (parse-integer (third datestring)))<br>	   (event-time (encode-timestamp 0 0 minute hour day month year :offset timezone)))<br>      (list event-time<br>	    (timestamp- event-time reminder-time-period :sec)))))<br></pre><br><br>The validation functions are ORs with the function testing the input as the first clause and a VALUES form returning nil (a failed submission) and an appropriate error message as the second. The helper functions use the with-form-values macro to grab the relevant fields of the form and construct the resulting slot. Get-timestamps is rather nasty but we're essentially just grabbing all those fields pertaining to the time, parsing the integers from them and passing those on to the appropriate <a href="http://common-lisp.net/project/local-time/manual.html#Creating-timestamp-Objects">timestamp</a> <a href="http://common-lisp.net/project/local-time/manual.html#Manipulating-Date-and-Time-Values">functions</a> in the local-time library.<br><br><h3>A Calendar Presentation</h3><br>It would certainly be better to have a nice calendar than have users enter dates as strings and then try to validate them and God forbid we roll our own given the number of Javascript calendars already out there. Since it's fairly well established I opted for the <a href="http://docs.jquery.com/UI/Datepicker">jQueryUI Datepicker</a>. Previously to use Javascript libraries you needed to download them and place them in your Weblocks project's pub/script folder but thanks to a quick patch by Leslie Polzer remote dependencies are now also supported. In case you didn't read the previous article, when you first start a project with <code>(wop:make-app 'name "/path/to/app")</code> weblocks generates a defwebapp form and a basic package for that app along with setting up a store and some basic resources. To include the jQuery code on our page we'll modify our defwebapp form in clockwork.lisp like so:<br><pre lang="lisp"><br>(defwebapp clockwork<br>    :prefix "/"<br>    :description "Fire-and-Forget Event Reminders"<br>    :init-user-session 'clockwork::init-user-session<br>    :autostart nil                   ;; have to start the app manually<br>    :ignore-default-dependencies nil ;; accept the defaults<br>    :hostnames '("clockwork.redlinernotes.com")<br>    :dependencies '((:stylesheet "http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.5/themes/ui-darkness/jquery-ui.css")<br>		    (:script "http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js")<br>		    (:script "http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.5/jquery-ui.min.js")<br>		    (:javascript-code "var $jquery = jQuery.noConflict();"))<br>    :debug t)<br></pre><br><br>First let's note that this will include these dependencies in the "HEAD" of every page. If you want to have per-widget dependencies Weblocks does support that by (if I'm not mistaken) defining a <a href="http://common-lisp.net/project/cl-weblocks/docs/weblocks-package/generic-efunction-widget--public--dependencies.html">widget-public-dependencies</a> method specialized on that widget. Since we only have one page in this app anyway we'll just list them here. We've done that by adding entries to the dependencies list that use Google's CDN to supply the minified jQuery and jQueryUI libraries along with a stylesheet for the jQueryUI stuff. We added the :hostnames argument which specifies that requests to any host besides those listed are to be ignored. This is particularly helpful if you're running multiple webapps off of one server but want them to share a Lisp image and port rather than fire up separate Hunchentoot servers for each one. Additionally, we're inlining the js code that calls <code>jQuery.noConflict()</code> in the header because Weblocks uses prototype and scriptaculous out of the box and jQuery will happily steal the <strong>$</strong> global variable from Prototype which causes all sorts of havoc. While there is interest in removing the prototype and scriptaculous dependencies it hasn't happened yet. It would be greatly appreciated if any developer felt like taking a little time to tackle this.<br><br>So now that we've included the JS code, let's write a presentation. The presentation lets us add the code <code>:present-as (calendar)</code> to a slot in our View and have it render as a calendar. This presentation will be a little different as we're using Leslie's new form-widget code. A more traditional coverage of presentations can be found in <a href="http://uint32t.blogspot.com/2008/04/weblocks-presentations.html">this blog post</a>. Create a new file in the src directory called calendar.lisp and insert the following code:<br><pre lang="lisp"><br>(in-package :clockwork)<br><br>;; calendar presentation<br>(defclass calendar-presentation (input-presentation)<br>  ())<br><br>;; calendar form-widget code<br>(define-widget calendar-field-widget (field-widget)<br>  ()<br>  (:default-initargs :parser (lambda (raw-value)<br>			       (values t raw-value))))<br><br>(defmethod field-presentation->field-widget-class ((presentation calendar-presentation))<br>  'calendar-field-widget)<br><br>(defmethod render-field-contents ((form form-widget) (field calendar-field-widget))<br>  (with-html<br>    (:input :type "hidden" :name (name-of field) :value (datestring))<br>    (:div :id "datepicker"<br>      (send-script '($jquery (lambda ()<br>			       (ps:chain ($jquery "#datepicker")<br>					 (datepicker (ps:create date-format "dd-mm-yy"<br>                                                                min-date 0<br>								on-select (lambda (date inst)<br>									    (ps:chain ($jquery "[name=event-date]")<br>										      (val date))))))))))))<br><br>(defun datestring ()<br>  (subseq (format-timestring nil (now) :format '((:day 2) "-" (:month 2) "-" :year)) 0 10))<br></pre><br><br>So what's going on here? First we define a calendar-presentation class and a calendar-field-widget class along with a simple method to map the presentation onto the widget-class. Then we write the bulk of the code, a render-field-contents method which generates the HTML and Javascript. We'll use a hidden input field with a name equal to the field in the view that gets initialized to today's date. That will be followed by a div containing the Javascript code for the datepicker written with Parenscript (indentation suggestions welcome) which sets the hidden input field whenever a date is selected.<br><br><h3>Putting it all together...</h3><br>Now that we have all the pieces we need we can hook them together. You'll note that a src/init-session.lisp file already exists and contains a defun for init-user-session. This function sets up the widget tree and creates a new session when users visit the site. Remove the old definition and insert the following into the file:<br><pre lang="lisp"><br>(defun init-user-session (root)<br>  (setf (widget-children root)<br>	(make-reminder-form)))<br><br>(defun make-reminder-form ()<br>  (let ((reminder-form (make-instance 'form-widget :on-success 'submit-reminder-form)))<br>    (form-widget-initialize-from-view reminder-form 'reminder-form-view)<br>    reminder-form))<br></pre><br>We're just defining a separate function <code>(make-reminder-form)</code> to create our form instance here rather than defining it inline in the init-user-session code. Make-reminder-form itself creates an instance of the form-widget class which runs a function called submit-reminder-form when the form is successfully submitted (i.e. passes validation, etc). Note that we have not yet defined submit-reminder-form. Because the form is really based on a view and not a widget or class we want to persist we'll use form-widget-initialize-from-view in conjunction with the reminder-form-view we defined earlier. Note that you may need to restart the webapp after redefining the init-user-session function. Run <code>(restart-webapp 'clockwork)</code> and check the homepage. You should now have a nice form complete with jQuery Datepicker. But of course, nothing useful happens on submission. Time to fix that by going ahead and defining submit-reminder-form. Open src/init-session.lisp back up and insert the following:<br><br><pre lang="lisp"><br>(defun submit-reminder-form (widget)<br>  (let ((new-reminder (create-reminder widget)))<br>    (schedule new-reminder)<br>    (persist-object *clockwork-store* new-reminder))<br>  (reset-form-widget widget))<br><br>(defun create-reminder (form-data)<br>  (with-form-values (subject summary) form-data<br>    (let ((timestamps (get-timestamps form-data)))<br>      (make-instance 'reminder<br>		     :emails (get-emails form-data)<br>		     :title subject<br>		     :summary summary<br>		     :timestamp (first timestamps)<br>		     :at (second timestamps)))))<br></pre><br>Note that I wrote this in a way that's fairly natural to Lisp. I wrote submit-reminder-form in what almost resembles pseudocode and ensured it expressed my intent before worrying about writing a helper function to make that possible. So submit-reminder-form creates a new-reminder by passing the widget to create-reminder, schedules and saves that new-reminder in the Prevalence store and then resets the form. To make this possible, create-reminder uses with-form-values to scrape out the subject and summary from the form, then we grab the timestamps and emails using the functions we wrote for that earlier and instantiate the reminder object accordingly. At last the site is fully functional for sending email or text message reminders!<br><br><h3>Recovering from Failure</h3><br>We haven't covered what to do in case of an emergency reboot or other failure. Since everything is persisted by prevalence on submission the *clockwork-store* will still have our reminders. All we have to worry about is ensuring that all the timers get rescheduled. This is so simple it hurts. Reopen src/reminder.lisp and add the following code to the bottom of the file:<br><pre lang="lisp"><br>(defun recover-reminders ()<br>  "A function to reschedule reminders after a reboot. Based on testing,<br>any that expired during the reboot will be sent when the schedule method is called.<br>Better late than never, right?"<br>  (mapcar #'schedule (find-persistent-objects *clockwork-store* 'reminder)))<br></pre><br><br>Calling <code>(recover-reminders)</code> will schedule all the reminders in the store and whether Linux, SBCL or trivial-timers is to thank, a timer that's scheduled in the past will trigger immediately so you don't have to worry about some being lost during the reboot itself. Just add <code>#:recover-reminders</code> to the export list in the clockwork defpackage in clockwork.lisp and then call it after you load clockwork in your init.lisp file that runs when the server starts. Here's my <a href="http://github.com/redline6561/dotfiles/blob/master/server/configs/webapps/init.lisp">init.lisp</a> as an example.<br><br><h3>Next time...</h3><br>At this point we've seen a tiny bit of the Store API and the default Prevalence store and learned a little about widgets and views. We still need to cover actions and navigation/dispatchers and it wouldn't hurt to demonstrate user registration and authentication as well as use of a SQL backend. Sooner or later we'll get around to all of those things.<br><br>Right now I'm working on a postmodern backend for weblocks and may also work on styling, polish, error handling and potentially a new feature or two for clockwork. Based on what gets done, the next article will either cover the beginning of a new project or continued improvements to clockwork.
