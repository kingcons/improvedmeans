;;;;;
title: SICP Section 1.1
tags: LISP, Self-Learning, SICP
date: 2008-01-19 03:18:23
format: html
;;;;;
<p>Well, <a href="http://www./&">I said I would do this and I meant it</a>. These entries will be a bit lengthy. I feel a little pain for any feeds I'm aggregated on. So, in the interest of not driving you all mad, these weekly semester updates will be behind a cut. <!--more--></p><br><p>Like so.</p><br><p>With that out of the way, here are the details. Each week, I'll post the resources I used (i.e. what I read, what I watched, etc) and the solutions to the relevant problems along with any notes of interest I had. I may offer other general musings (or even specific ones) inspired by my studies in other posts but these will tend towards a cut and dry solution to the exercises. Finally, I'll post a link to any sources I might have found or used to check answers I wasn't sure of and if I got the answer wrong I'll disclose that in the post.</p><br><p>As for the math, I haven't decided what to do about that. I mean, it doesn't make sense to post up a ton of math solutions though I suppose by that logic it doesn't make sense to post code snippets either. If I come up with something I'll let you know. If you have suggestions by all means write them in.</p><br><p>Resources:<br /><br>Read: <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-9.html#%_chap_1" title="Start">Chapter 1</a> through <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1" title="Finish">Section 1.1</a><br /><br>Watch: <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/" title="Lectures">Lectures</a> <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/videos/Lecture-1a.avi">1-a</a><br /><br>Checked against: <a href="http://eli.thegreenplace.net/category/programming/lisp/sicp/">Eli Bendersky's Blog</a></p><br><p>SICP Notes and Exercises:</p><br><p>Notes<br /><br>Pgs. 28-30: Definitions and explanations of scope and locality. It is becoming evident that subtle errors can easily emerge due to differences in locality and scope. These errors are colluded by the fact that there is no distinction in lisp between variables and procedures. (i.e. you could have a procedure that used abs (another procedure) as a variable.)</p><br><p>Quotes<br /><br>"First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute." - Preface to the First Edition</p><br><p>"The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology - the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects." - Preface to the First Edition</p><br><p>Exercises<br /><br><a href="http://sicp.org.ua/sicp/Exercise1-2">1.2</a>:</p><br><pre lang="lisp"><br>(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 3))))) (* 3 (* (- 6 2) (- 2 7))))<br>;Value: -23/90</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-3">1.3</a>:</p><br><pre lang="lisp"><br>(define (two-of-three x y z)<br>  (cond ((< x y z) (+ (* y y) (* z z)))<br>	((< y x z) (+ (* x x) (* z z)))<br>	((< z x y) (+ (* x x) (* y y)))<br>	((or (= x y) (= x z)) (+ (* y y) (* z z)))<br>	((or (= y x) (= y z)) (+ (* x x) (* z z)))<br>	((or (= z x) (= z y)) (+ (* x x) (* y y)))))<br>;Value: two-of-three</pre><br><p>Comments: The original version of the program lacked the last three lines but I realized if you got inputs that were equal to each other there wasn't a condition that matched that so I changed it. I'm sure there's a much more elegant way to do it but the job is done. And it's mostly readable.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-4">1.4</a>:<br /><br>This procedure checks to see if B is greater than 0. If it is, it adds A and B. Otherwise, it subtracts B from A.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-5">1.5</a>:<br /><br>This procedure when evaluated using applicative-order evaluation will not resolve as it infinitely recurses trying to evaluate (p). An interpreter using Normal-order evaluation will not have this problem because in the example the if condition evaluates to true so the p function is never evaluated. (The Scheme interpreter uses Applicative-Order evaluation.)</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-6">1.6</a>:<br /><br>Again, this is a case of infinite recursion due to Applicative-Order evaluation. Sqrt-iter continues to call itself regardless of the value of (good-enough? guess x) if you must know.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-7">1.7</a>:</p><br><pre lang="lisp"><br>(define (good-enough? guess x)<br>  (< (abs (- (improve guess x) guess)) (* 0.000001 guess)))<br>;Value: good-enough?</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-8">1.8</a>:</p><br><pre lang="lisp"><br>(define (curt-iter guess x)<br>  (if (good-enough? guess x)<br>      guess<br>      (curt-iter (improve guess x) x)))<br>;Value: curt-iter<br><br>(define (good-enough? guess x)<br>  (< (abs (- (cube guess) x)) 0.001))<br>;Value: good-enough?<br><br>(define (cube x)<br>  (* x (* x x)))<br>;Value: cube<br><br>(define (curt x)<br>  (curt-iter 1.0 x))<br>;Value: curt<br><br>(define (improve guess x)<br>  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))<br>;Value: improve</pre><br><p>##NOTE:<br /><br>Here is an example rewrite of the sqrt program using block structure and lexical scoping. It is inserted here because this was the point of discussion but no relevant exercise was assigned.</p><br><pre lang="lisp"><br><br>(define (sqrt x)<br>    (define (sqrt-iter guess)<br>        (if (good-enough? guess)<br>            guess<br>            (sqrt-iter (improve guess))))<br>    (define (good-enough? guess)<br>        (< (abs (- (square guess) x)) 0.001))<br>    (define (average a b)<br>        (/ (+ a b) 2))<br>    (define (improve guess)<br>        (average guess (/ x guess)))<br>    (sqrt-iter 1.0))</pre>
