;;;;;
title: Quick Thoughts on Languages
tags: Programming Languages
date: 2009-03-26 16:37:21
format: html
;;;;;
<p>John Wiegley posted an article that I thought was fun a week or so back called "Hello Haskell, Goodbye Lisp". Naturally, it made it on <a href="http://news.ycombinator.com/item?id=516038">Hackernews</a> and <a href="http://www.reddit.com/r/programming/comments/84o17/hello_haskell_goodbye_lisp/">Reddit</a> and there were comments of all stripes. Whenever somebody posts an article about a language they're learning the initial reaction from some folks is "What an idiot. Implement something big and hard already!" and I think that is a bit obnoxious as well as missing the point. John Wiegley doesn't think he's a genius because he cracked Haskell's code. I think he knows that Haskell is a deep language and he's playing in the shallow end. What he (and many other people) are trying to figure out is which Programming Languages are equipped to deal with the future requirements of programming well and where the languages stand in terms of personal appeal.</p><br><p>Someone mentioned that Clojure would've been a more fair comparison for Haskell than Common Lisp and there's some truth to that. You'd think that Wiegley being a Lisp fan would cause him to lean towards Clojure but he <a href="http://www.newartisans.com/2009/03/the-jvm-and-costs-vs-benefits.html">really doesn't like the JVM for scripting</a>. Why? He thinks it's startup times are unacceptable. I don't mind that but I'd be more concerned about the difficulty in producing standalone binaries and the reliance on having a JRE installed at all. It's just not my thing but that's what we're talking about here: preferences.</p><br><p>Different languages are suited to different domains. It's so bad I'm not even sure I believe in the phrase "general purpose languages" anymore. You've got the "server/enterprise" languages (Java,C#,etc), "scripting" languages (Python/Perl/Ruby generally, PHP/JS for web), "embedded" languages (Forth, C/C++, Lua), and then C and C++ again for Operating Systems, Compilers, "low level stuff" and real-time applications/games. Not that games don't often contain twice as much in the way of Lua\Python scripts as C++ core. *sigh*</p><br><p>So, let's be clear. You have to know several languages and the question is: Which languages do I use to be the most happy and efficient? I want my programming future to be fun! My thoughts are presently as follows. I'm not sure how many languages you can <em>really</em> hold in your head at one time. For regular, proficient (expert?) use I'd say I think 2-3 is about right and a half dozen is possible. I have a hard time imagining simultaneous mastery and regular use of 12 languages. I'm going to try to keep my list to 5 languages.</p><br><p>1. You have to be able to deal with C. You just do. It doesn't hurt to know assembly (ARM, 6502, x86, or whatever) but you have to be able to deal with C. If only to create bindings from other languages to C code. So deal. At least we now have a Low-Level and Embedded language covered that will give us the ability to work with lots of Open Source Software and older code. Also, I didn't choose C++ because I think C is simpler and cleaner. Obviously, there's a lot of C++ code around but trying to really know C++ has to be equivalent to really knowing 2 or 3 other languages. I'm skeptical. Again, preferences.</p><br><p>2. Python has lots of libraries, lots of existing code, and is reasonably readable and self-consistent. I think it serves as a good scripting language and can be used for web development fairly well (see: reddit). Plus it's actually employable and higher level than C.</p><br><p>3. I like Lisps. Don't ask me why, it's just a preference and I think they're fun. My priorities with a Lisp are being able to work with C code well, produce fast native code (preferably with some plan for multicore {futures,stm,threading solution,shared nothing message passing, etc), generate standalone executables and have a decent collection of libraries. That leaves me torn between SBCL (30MB hello-world?! I guess I could use CLISP but what about multicore performance?), Chicken Scheme (multicore performance again? they do have futures...) and Clojure (I need the JVM, you don't do standalone binaries, and there's no asdf/rubygems/cabal/chicken-setup/easy_install/anything?). *sigh* Oh, lisp.</p><br><p>4. Haskell does have some advantages. As far as I know it's the most "parallel-ready" programming language presently available. This is largely because it has solutions for the most granularities of parallel\concurrent code. And yes, I know parallelism and concurrency aren't the same thing...even though Wikipedia confuses them. Erlang, Scala and Clojure all have benefits but for various reasons Haskell is my pick of the lot. I'm open to that changing but it wouldn't hurt to know a lazy, bondage and disciple-style typed functional language regardless. It's an interesting way of thinking. Hackage is reasonably impressive considering the youth of the language in terms of mainstream use and Hayoo and Hoogle are quite unusual and cool methods for code search. The quality of the toolset is also impressive (GHC,Haddock,QuickCheck,Cabal,etc).</p><br><p>5. Factor. I'm not trying to be weird here, I'm just interested in knowing a concatenative language. The library support is pretty good. The code looks pretty clean. It produces standalone binaries which are both pretty small and pretty fast. I feel like a lot of smart design decisions have been made. I'm really interested in seeing where Factor goes. There are a considerable number of libraries given the number of people working on Factor and it's age. Hopefully, it'll only keep getting better.</p><br><p>So, what are my preferences stated more explicitly?</p><br><ul><br><li>I prefer the late-binding/dynamic/whatever-the-hell-you-want-to-call-them languages like Lisp, Scheme, and Factor. They just make the development process more fun than anything else I've worked with. Clojure tempts me but the lack of standalone binaries, package management, and the requirement on the JVM makes me a little nauseous. I don't think Emacs is too heavyweight for text editing but I think <em>that's</em> too heavyweight. Sadly, these languages appear to me to be in the worst library position, save Clojure which is saved via Java. There's a lot of division of effort among the others and there always has been.</li><br><li>Haskell in emacs with ghci open in a shell isn't perfect but it isn't bad either and you do get all that type safety/power/relatively-painless-multicore-speedups. Plus the libraries and hayoo/hoogle, etc are pretty great.</li><br><li>As for C and Python, they're on the list so I can possibly be employed at some point as well as play in the codebases of my favorite Open Source Software.</li><br></ul><br><p>I like High Level Languages and I like a lean towards functional programming. Haskell has been fun and I'm now interested in type systems that are actually nice to use but I would still run to a Lisp that made fast parallel code easily, even if it meant having some special typing constructs just for stateful behavior. Object Orientation was the hammer used to hit everything that looked like a nail for the last 20 years and while it unquestionably has it's place, I prefer the functional style in my personal experience where possible. That may well change when I start writing projects &gt; 1000 LOC. Other than that, I just want a nice development environment and good libraries.</p><br><br>Before I forget, I should note that <a href="http://www.reddit.com/r/programming/comments/86zjg/ask_proggit_im_15_and_i_absolutely_love/c08f6wi">gaze made a very good comment</a> worth keeping in mind on a recent reddit thread about programming languages which I'll try to sum up in a sentence or two: "The important part of a programming language is using it. You'll learn theory as you go, now write code." Anyway, I'm going to run away from social news sites for a bit and try to get some real work done.
