;;;;;
title: A Summer Schedule and 10,000 Hours
tags: Personal, Self-Learning
date: 2010-05-17 13:00:35
format: html
;;;;;
Today is the first day of my summer courses. I'll be taking Distributed Computing, Programming Language Concepts, Information Security Administration, Astronomy and the corresponding Astronomy lab and cramming all that into 8 weeks. Hooray. The Distributed Computing and PLC courses are online which helps ease my scheduling and transportation concerns somewhat...though by the end of summer there is a possibility I'll have a car again obviating my need to take public transit an hour and a half to get to campus. As it stands, classes are Monday through Thursday, start between 10 and Noon and end by 3pm everyday.<br><br>That ought to give me plenty of time to work on personal studies...but there's a problem with that. I haven't been good about making my personal CS studying <a href="http://redlinernotes.com/blog/?p=638">structured</a> since the great 2008 <a href="http://redlinernotes.com/blog/?p=665">experiment</a>/<a href="http://redlinernotes.com/blog/?p=750">debacle</a>. There are a lot of reasons for that experiment's failure. I lost steam studying only SICP in 2008 and not having any immediate idea how to write software that was useful to me or anybody else. Perhaps more significantly, I wound up with not only a full time job but also housewife duties in May 08 which practically ended the time and tight scheduling that had been crucial to my progress. I'm likely still going to have housewife duties but I think I can carve out enough time this summer to give things another go.<br><h3>Why Bother?</h3><br>Long before <em>Outliers</em>, many studies suggested that 10,000 hours of practice are required to achieve expertise. Peter Norvig has a post called "<a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a>" that is often linked to in discussions of learning to program and it links to a few of these studies. ...but that link is, perhaps, a bit over cited and it's impact softened as a consequence. I prefer the <a href="http://news.ycombinator.com/item?id=1061101">comment by nostrademons on that post</a>, reproduced here for posterity:<br><blockquote><span style="color: #000000;">I don't think it works quite like that.</span><br><br><span style="color: #000000;">When I got my first programming job, straight out of high school, I finished tasks in 2 days that took the other programmers there 4 months. I figured that if I was that much faster than them, I ought to be able to become a world-class programmer in just a couple years (or more accurately, I thought I could become a world-class physicist in my 4 years of college and then a world-class programmer in the 2 years afterwards).</span><br><br>So I resolved to take all the shortcuts I could. I'd read all the classic books in the field and learn from those with more experience than me. I'd take internships with experienced, accomplished programmers and pick their brains for everything I could. I'd take on volunteer coding tasks so I could get some experience building things on my own. I'd cherry-pick all the tough courses at college so I got the best part of a CS degree without having to sit through stuff I already knew.<br><br>I did all that. I've read all the classic CS books - GoF patterns, Mythical Man Month, Extreme Programming stuff, Pragmatic Programmer, Knuth, SICP, TAPL, Dragon Book, On Lisp, etc. I've worked with programmers that wrote large chunks of curses, Rogue, vi, Jini, JavaSpaces, HotSpot, Gallery, Stratus, Equalogic, DEC compilers, Python, Google, and a bunch of other projects they don't brag about. I wrote Amherst's course-evaluation system, and rewrote the software for a 100k-user site, and wrote one of the front-page hits for [haskell tutorial]. I have that CS degree, and aced the algorithms class of which you speak, and took compiler design and OS and computer graphics too.<br><br>It's been 9.5 years since that first programming job, and it still feels like I have a really long way to go before I'm actually a world-class programmer.<br><br>The part I didn't realize, in my youthful arrogance, was that I was comparing myself to the wrong people. When Norvig tells you how to become a programmer in 10 years, he's assuming you're already taking all the shortcuts you can. It still takes 10 years. Most of the people you'll meet straight out of high school, or in most colleges, or in random companies, will never become programmers in the sense that Norvig's talking about. Eventually they'll give up trying, and start grumbling on Reddit about how the software industry is mostly boring cubicle farms where they push around Enterprise JavaBeans and never use the algorithms that they learned in college.</blockquote><br><span style="color: #000000;">Let me just say, I *love* this comment. I've thought about printing it out, hanging it over my bed and reading it before I go to sleep every night just for the kick in the ass it gives me. I'm probably too relaxed to ever achieve the level of expertise nostrademons is talking about (and see the "experiment" link above if you don't believe me) but I want to keep learning. I think it is far too easy in this field to not follow both theory and practice, to either stop writing code or stop keeping up with the theory. I have a real passion and interest for programming and I plan to try to avoid that.</span><br><h3><span style="color: #000000;">How To Do It</span></h3><br>I'm not sure to what degree schoolwork, paid work or personal projects can contribute to the 10,000 hour figure. I feel like if it's not a concerted effort to get better in an area where you are weak or otherwise generate forward motion, if it's not dedicated practice rather than plodding repeated movements, it doesn't count. Many of us are adults though and if you want 8 hours of sleep 7 nights a week with social time, transit time, time to eat and time to relax then a week goes from 168 hours to 112 hours to 72 hours (after a 40 hour workweek) to less really quick.<br><br>Assuming you set aside an hour every work day (M-F) for dedicated personal studies, 52 weeks a year, it would take you about 40 years to achieve 10,000 hours. I have to assume Norvig or others would include school or a job assuming that it continued to push your limits. Otherwise, we're talking 20 hours a week (or 4 hours after work+school+etc every workday) to get there in 10 years. At any rate, I've said I'm in no rush and that I'm probably too relaxed to achieve the level of expertise discussed above. As a consequence, I'll only do 5 hours a week from 4-5pm Monday through Friday.<br><br>I'm not going to have quite as structured a study plan as I did in 2008 though I will be doing the exercises, there will be specific books I study from and hopefully I'll find time to blog about it and not just push to github. Monday-Tuesday will be <a href="http://csapp.cs.cmu.edu/">Computer Systems: A Programmer's Perspective by Bryant and O'Hallaron</a>, Wednesday-Thursday will be <a href="http://www.aw-bc.com/info/kleinberg/index.html">Algorithm Design by Kleinberg and Tardos</a> and Friday will be <a href="http://norvig.com/paip.html">Peter Norvig's Paradigms of Artificial Intelligence Programming in Common Lisp</a>. Let's see how this goes...
