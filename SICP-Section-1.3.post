;;;;;
title: SICP Section 1.3
tags: LISP, Self-Learning, SICP
date: 2008-04-01 02:31:48
format: html
;;;;;
<p>At long last, I'm through Chapter 1 of SICP. I'm a bit disappointed that <a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">Closures</a> haven't been covered yet but they're in the first few pages of Chapter 2 and I've already got a few problems solved. As a matter of fact, I finished Chapter 1 last Wednesday it just takes time to get these posts up. I have a feeling I need to go back and study those explanations of <a href="http://en.wikipedia.org/wiki/Scope_(programming)">Lexical Scope</a> in Chapter 1 though. I'll try to write more about the experience thus far in a separate post. For now, here are my results for Section 1.3.</p><br><p><!--more--></p><br><p>Resources:<br /><br>Read: <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-9.html#%_chap_1">Chapter 1</a> through <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html">Section 1.3</a><br /><br>Watch: <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/">Lectures</a> <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/videos/Lecture-2a.avi">2-a</a><br /><br>Checked against: <a href="http://eli.thegreenplace.net/category/programming/lisp/sicp/">Eli Bendersky's Blog</a>, <a href="http://sicp.org.ua/sicp/Section1-3">SICP Wiki</a>, <a href="http://www.kendyck.com/solutions-to-sicp/">Ken Dyck's Solutions</a>, <a href="http://theloserblog-home.blogspot.com/search/label/SICP">Theloserblog</a>, <a href="http://wfasim.dyndns.org/wordpress/?page_id=136">Wfasim's Solutions</a>, <a href="http://www.michaelharrison.ws/weblog/?p=47">Autodidact</a> and <a href="http://lispy.wordpress.com/2007/09/22/mastering-higher-order-programming-techniques-with-sicp-chapter-1/">Lispy</a> for Inspiration.</p><br><p>SICP Notes and Exercises:</p><br><p>Notes<br /><br>Pgs. 63-66: Discussion of Let and Local Variable Binding.<br /><br>Pg. 76: Discussion of First-Class Status in programming languages.</p><br><p>Quotes<br /><br>"I'm going to write the...procedure here explicitly without giving it a name. I'm doing it anonymously, I don't necessarily have to give a name to something if I just want to use it once." - Gerald Jay Sussman, approx. 17:00, Lecture 2-a</p><br><p>"Procedures can be named by variables. Procedures are not special...Therefore they can be passed from one to another as arguments." - Gerald Jay Sussman, approx. 20:00, SICP Lecture 1-B from Swiss Archive, Higher-Order Functions Explanation</p><br><p>"Talent is to a great extent knowledge that we haven't yet learned how to formalize." - Gerald Jay Sussman, approx. 55:00, <a href="http://www.aduni.org/colloquia/sussman/">The Legacy of Computer Science</a></p><br><p>Exercises<br /><br><a href="http://sicp.org.ua/sicp/Exercise1-29">1.29</a>:</p><br><p>This exercise definitely wasn't easy. I think most of the difficulty is in figuring out how the math works and how the functions are all feeding into each other.</p><br><pre lang="lisp">(define (cube x) (* x x x))<br>;Value: cube<br><br>(define (sum term a next b)<br>  (if (> a b)<br>      0<br>      (+ (term a)<br>         (sum term (next a) next b))))<br>;Value: sum<br><br>(define (simpsons-rule f a b n)<br>  (define h (/ (- b a) n))<br>  (define (k-term x)<br>    (cond ((or (= x 0) (= x n)) 1)<br>	  ((even? x) 2)<br>	  (else 1)))<br>  (define (yk x)<br>    (* (k-term x)<br>       (f (+ a (* x h)))))<br>  (* (sum yk a (lambda (x) (+ x 1)) n)<br>     (/ h 3)))<br>;Value: simpsons-rule<br><br>(simpsons-rule cube 0 1 100)<br>;Value: 1/4<br><br>(simpsons-rule cube 0 1 1000)<br>;Value: 1/4</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-30">1.30</a>:<br /><br>Personally I think it's really nice that Abelson and Sussman have been throwing in these sort of review problems. They make me feel like I'm learning something. They give me hope. I solved this one in about 1 minute and a half and thought, "Hey, maybe I'm not a complete idiot. Maybe I'll actually know something about programming one day."</p><br><pre lang="lisp">(define (sum term a next b)<br>  (define (iter a result)<br>    (if (> a b)<br>        result<br>        (iter (next a) (+ (term a) result))))<br>  (iter a 0))<br>;Value: sum</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-31">1.31</a>:</p><br><p>a.</p><br><pre lang="lisp">(define (product term a next b)<br>  (if (> a b)<br>      1<br>      (* (term a)<br>	 (product term (next a) next b))))<br>;Value: product<br><br>(define (factorial n)<br>  (product (lambda (x) x) 1 (lambda (x) (+ x 1)) n))<br>;Value: factorial<br><br>(define (pi-approx approximations)<br>  (define (pi-term denom) (/ (- (square denom) 1) (square denom)))<br>  (define (next-term denom) (+ denom 2))<br>  (product pi-term 3 next-term approximations))<br>;Value: pi-approx<br><br>(pi-approx 40)<br>;Value: 4722366482869645213696/5938020471163465810125 (.795276)</pre><br><p>I just changed the variable names and commented pi-approx. The comment is omitted here in favor of this explanation. I couldn't figure out what on earth I was doing in the original so I actually wrote a brand new pi-approx with a different approach before realizing my original version was both correct and, I suspect, faster. I was computing 2 terms at a time based on their shared denominator.</p><br><p>b.</p><br><pre lang="lisp">(define (product term a next b)<br>  (define (iter a result)<br>    (if (> a b)<br>	result<br>	(* (term a)<br>	   (product term (next a) next b))))<br>  (iter a 1))<br>;Value: product</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-32/">1.32</a>:</p><br><p>a.</p><br><pre lang="lisp">(define (accumulate combiner null-value term a next b)<br>  (if (> a b)<br>      null-value<br>      (combiner (term a)<br>		(accumulate combiner null-value term (next a) next b))))<br>;Value: accumulate<br><br>(define (sum term a next b)<br>  (accumulate + 0 term a next b))<br>;Value: sum<br><br>(define (product term a next b)<br>  (accumulate * 1 term a next b))<br>;Value: product</pre><br><p>b.</p><br><pre lang="lisp">(define (accumulate combiner null-value term a next b)<br>  (define (iter a result)<br>    (if (> a b)<br>	null-value<br>	(combiner (term a)<br>		  (iter (next a) result))))<br>  (iter a null-value))<br>;Value: accumulate</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-33">1.33</a>:</p><br><pre lang="lisp">(define (filtered-accumulate combiner null-value term a next b filter)<br>  (cond ((> a b) null-value)<br>	((filter a) (combiner (term a)<br>			       (filtered-accumulate combiner null-value term<br>						    (next a) next b filter)))<br>	(else (filtered-accumulate combiner null-value term<br>				   (next a) next b filter))))<br>;Value: filtered-accumulate</pre><br><p>a.</p><br><pre lang="lisp">(define (sum-square-primes a b)<br>  (filtered-accumulate + 0 square a inc b prime?))<br>;Value: sum-square-primes</pre><br><p>b.</p><br><pre lang="lisp">(define (product-relative-primes n)<br>  (define (relatively-prime i)<br>    (= (gcd i n) 1))<br>  (filtered-accumulate * 1 identity 1 inc n relatively-prime))<br>;Value: product-relative-primes</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-34">1.34</a>:<br /><br>The procedure f only actually produces output when it's argument is another procedure, specifically a procedure which takes one formal parameter. Given a procedure of a different arity it will produce an error regarding the wrong number of arguments and given a non-procedural argument it will complain about the object not being applicable.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-35">1.35</a>:</p><br><pre lang="lisp">(define tolerance 0.00001)<br>;Value: tolerance<br><br>(define (fixed-point f first-guess)<br>  (define (close-enough? v1 v2)<br>    (< (abs (- v1 v2)) tolerance))<br>  (define (try guess)<br>    (let ((next (f guess)))<br>      (if (close-enough? guess next)<br>          next<br>          (try next))))<br>  (try first-guess))<br>;Value: fixed-point<br><br>(define (golden-ratio)<br>  (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0))<br>;Value: golden-ratio<br><br>(golden-ratio)<br>;Value: 1.6180327868852458</pre><br><p>Things are pretty straightforward from 1.29 through 1.36. The main thing to remember on 1.35 and 1.36 is that a transformation is just a function and serves as the f in the fixed-point.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-36">1.36</a>:</p><br><pre lang="lisp">(define (fixed-point f first-guess)<br>  (define (close-enough? v1 v2)<br>    (< (abs (- v1 v2)) tolerance))<br>  (define (try guess)<br>    (let ((next (f guess)))<br>      (display guess)<br>      (newline)<br>      (if (close-enough? guess next)<br>	  next<br>	  (try next))))<br>  (try first-guess))<br>;Value: fixed-point<br><br>(define (solve-for-x)<br>  (fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0))<br>;Value: solve-for-x<br><br>(solve-for-x)<br>2.<br>9.965784284662087<br>3.004472209841214<br>6.279195757507157<br>3.759850702401539<br>5.215843784925895<br>4.182207192401397<br>4.8277650983445906<br>4.387593384662677<br>4.671250085763899<br>4.481403616895052<br>4.6053657460929<br>4.5230849678718865<br>4.577114682047341<br>4.541382480151454<br>4.564903245230833<br>4.549372679303342<br>4.559606491913287<br>4.552853875788271<br>4.557305529748263<br>4.554369064436181<br>4.556305311532999<br>4.555028263573554<br>4.555870396702851<br>4.555315001192079<br>4.5556812635433275<br>4.555439715736846<br>4.555599009998291<br>4.555493957531389<br>4.555563237292884<br>4.555517548417651<br>4.555547679306398<br>4.555527808516254<br>4.555540912917957<br>;Value: 4.555532270803653<br><br>(define (solve-for-x)<br>  (fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2.0))<br>;Value: solve-for-x<br><br>(solve-for-x)<br>2.<br>5.9828921423310435<br>4.922168721308343<br>4.628224318195455<br>4.568346513136242<br>4.5577305909237005<br>4.555909809045131<br>4.555599411610624<br>4.5555465521473675<br>;Value: 4.555537551999825</pre><br><p>Pretty impressive. solve-for-x went from taking 34 steps to 9 steps thanks to average damping. I wonder what it does for golden ratio? And sqrt's for various inputs...</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-37">1.37</a>:<br /><br>a.</p><br><pre lang="lisp">(define (cont-frac n d k)<br>  (define (frac-iter i)<br>    (if (< i k)<br>	(/ (n i) (+ (d i) (frac-iter (+ i 1))))<br>	(/ (n i) (d i))))<br>  (frac-iter 1))<br>;Value: cont-frac<br><br>(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 11)<br>;Value: .6180555555555556</pre><br><p>b.</p><br><pre lang="lisp">(define (cont-frac n d k)<br>  (define (frac-iter count result)<br>    (if (= count 0)<br>	result<br>	(frac-iter (- count 1)<br>		   (/ (n count) (+ (d count) result)))<br>  (frac-iter k 0))<br>;Value: cont-frac<br><br>(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 11)<br>;Value: .6180555555555556</pre><br><p>The main thing that's tricky about 1.37 is figuring out the math of continued fractions and starting with the base case of the last term and working backwards.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-38">1.38</a>:</p><br><pre lang="lisp">(define (euler-expand)<br>  (define (d-fun i)<br>    (cond ((= (modulo i 3) 2) (* (ceiling (/ i 3)) 2))<br>	  (else 1)))<br>  (cont-frac (lambda (i) 1.0) d-fun 8))<br>;Value: euler-expand<br><br>(euler-expand)<br>;Value: .7182795698924731</pre><br><p>So, my original iterative version of cont-frac didn't actually work for this problem. The iterative version didn't work for this problem because it treated division as though it's <a href="http://en.wikipedia.org/wiki/Commutativity">commutative</a> and it isn't. It took me a while to figure that out.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-39">1.39</a>:</p><br><pre lang="lisp">(define (tan-cf x k)<br>  (define (d i)<br>    (- (* 2 i) 1))<br>  (define (n i)<br>    (if (= x 1)<br>	x<br>	(square x)))<br>  (cont-frac n d k))<br>;Value: tan-cf<br><br>(tan-cf 1.0 5)<br>;Value: 1.5574074074074076</pre><br><p>This one is actually fairly tricky. If you fail to notice that this is a continued fraction that subtracts rather than adds you're completely hosed. I modified my cont-frac procedure to fix this once I noticed. There's probably an elegant way to extend cont-frac to accomodate these different uses (subtracting versus adding continued fractions, etc.) but I'm not going to chase it down myself. Anybody feel like improving on this?</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-40">1.40</a>:</p><br><pre lang="lisp">(define (cubic a b c)<br>  (lambda (x) (+ (expt x 3) (* a (expt x 2)) (* b x) c)))<br><br>(define dx 0.00001)<br>;Value: dx<br><br>(define (fixed-point-of-transform g transform guess)<br>  (fixed-point (transform g) guess))<br>;Value: fixed-point-of-transform<br><br>(define (cubic a b c)<br>  (lambda (x) (+ (expt x 3) (* a (expt x 2)) (* b x) c)))<br>;Value: cubic<br><br>(define (deriv g)<br>  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))<br>;Value: deriv<br><br>(define (newton-transform g)<br>  (lambda (x) (- x (/ (g x) ((deriv g) x)))))<br>;Value: newton-transform<br><br>(define (newtons-method g guess)<br>  (fixed-point (newton-transform g) guess))<br>;Value: newtons-method<br><br>(newtons-method (cubic 4 3 2) 1)<br>;Value: -3.2695308420809894</pre><br><p>I didn't realize I just needed to literally translate the function. After I knew that I was fine. Again, time to study more math.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-41">1.41</a>:</p><br><pre lang="lisp">(define (double x)<br>  (lambda (i) (x (x i))))<br>;Value: double<br><br>(define (inc x) (+ x 1))<br>;Value: inc<br><br>((double inc) 0)<br>;Value: 2<br><br>(((double (double double)) inc) 5)<br>;Value: 21<br><br>;;This is because a double on a (double double) is effectively a square.<br><br>(double double)<br>;Value 16: #[compound-procedure 16]<br><br>(((double (double double)) inc) 0)<br>;Value: 16<br><br>((double (double (double inc))) 0)<br>;Value: 8<br><br>(((double (double (double double))) inc) 0)<br>;Value: 256</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-42">1.42</a>:</p><br><pre lang="lisp">(define (compose f g)<br>  (lambda (i) (f (g i))))<br>;Value: compose<br><br>((compose square inc) 6)<br>;Value: 49</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-43">1.43</a>:</p><br><pre lang="lisp">(define (repeated f n)<br>  (if (= n 1)<br>      f<br>      (compose f (repeated f (- n 1)))))<br>;Value: repeated<br><br>((repeated square 2) 5)<br>;Value: 625</pre><br><p>Wow! That was a lot easier to think about using compose.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-44">1.44</a>:</p><br><pre lang="lisp">(define (smooth f)<br>  (define dx 0.00001)<br>  (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))<br>;Value: smooth<br><br>((smooth square) 2)<br>;Value: 4.000000000066667<br><br>(define (n-smoothed f n)<br>  (repeated smooth n) f)<br>;Value: n-smoothed<br><br>((n-smoothed square 16) 2)<br>;Value: 4</pre><br><p>Check <a href="http://theloserblog-home.blogspot.com/2007/11/sicp-exercise-144.html">The Loser Blog</a> for a potentially better answer.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-45">1.45</a>:</p><br><pre lang="lisp">(define tolerance 0.00001)<br>;Value: tolerance<br><br>(define (fixed-point f first-guess)<br>  (define (close-enough? v1 v2)<br>    (< (abs (- v1 v2)) tolerance))<br>  (define (try guess)<br>    (let ((next (f guess)))<br>      (if (close-enough? guess next)<br>	  next<br>	  (try next))))<br>  (try first-guess))<br>;Value: fixed-point<br><br>(define (average x y)<br>  (/ (+ x y) 2))<br>;Value: average<br><br>(define (average-damp f)<br>  (lambda (x) (average x (f x))))<br>;Value: average-damp<br><br>(define (nth-root x n)<br>  (fixed-point (repeated<br>		(average-damp (lambda (y) (/ x (expt y (- n 1)))))<br>		(ceiling (/ n 2))) 1.0))<br>;Value: nth-root<br><br>(define (compose f g)<br>  (lambda (x) (f (g x))))<br>;Value: compose<br><br>(define (repeated f n)<br>  (if (= n 1)<br>      f<br>      (compose f (repeated f (- n 1)))))<br>;Value: repeated<br><br>(define (nth-root x n)<br>  (fixed-point-of-transform (lambda (y) (/ x (expt y (- n 1))))<br>			    (repeated average-damp (log2 n)) 1.0))<br>;Value: nth-root<br><br>(define (log2 n)<br>  (if (= 1 n)<br>      0<br>      (+ (log2 (floor (/ n 2))) 1)))<br>;Value: log2</pre><br><p>After testing the first 15 powers with my version of nth-root I couldn't figure out the relationship between n and the times to average damp. Just about everyone had trouble with this but I found the correct answer in <a href="http://eli.thegreenplace.net/2007/07/19/sicp-section-134/#comments">Eli's comment thread</a>...</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-46">1.46</a>:</p><br><pre lang="lisp">(define (iterative-improve tester improver)<br>  (define (iter guess x)<br>    (if (tester guess)<br>	guess<br>	(iter (improver guess) x)))<br>  (lambda (x) (iter 1.0 x)))<br>;Value: iterative-improve<br><br>(define (sqrt x)<br>  ((iterative-improve<br>    (lambda (guess) (< (abs (- (square guess) x)) 0.00001))<br>    (lambda (guess) (average guess (/ x guess)))) x))<br>;Value: sqrt<br><br>(define (average x y)<br>  (/ (+ x y) 2))<br>;Value: average<br><br>(sqrt 2)<br>;Value: 1.4142156862745097<br><br>(define (fixed-point f x)<br>  ((iterative-improve<br>    (lambda (guess) (< (abs (- guess (f guess))) 0.00001))<br>    (lambda (guess) (f guess))) x))<br>;Value: fixed-point<br><br>(fixed-point cos 1.0)<br>;Value: .7390893414033927</pre><br><p>(Edit: 05/18/08) Well, that wraps it up for Section 1.3. I can't believe how long it took me to find the time to come back and clean these answers up a bit. I have had a lot going on though. There will be a few small changes in convention starting in SICP 2.1 to make things more manageable for me. As always, the most up to date code is in <a href="http://www.redlinernotes.com/code">the repo</a>.</p>
