;;;;;
title: A Brief, "Postmodern" Shout-out
tags: LISP, Personal, Programming
date: 2010-04-12 01:11:48
format: html
;;;;;
Things have been crazy lately but I'm not here to give a full update. I will say that there's been good with the bad, family, friends and supporters all the while and that the bad is mostly the usual bureaucratic and financial troubles that are just a part of life. I'm trying to post more regularly. Today is a brief programming post.<br><br>This semester I've been taking a database course and we're building a small, silly webapp as the final project. The course uses SQL+PHP and I asked my professor if he wouldn't mind if I used SQL+Common Lisp. He accepted and so I've been using the <a href="http://marijn.haverbeke.nl/postmodern/">Postmodern</a> library for Common Lisp to talk to my Postgresql database. Postmodern has been really nice to use so far but there's one thing that I had a little trouble with that I'd like to document here.<br><br>Generally, if you're writing classes in Lisp you're using CLOS and an example might be something like this:<br><pre lang="lisp">(defclass user ()<br>  ((username<br>    :initarg :username :reader :username)<br>   (password<br>    :initarg :password :reader :password)<br>   (salt<br>    :initarg :salt :reader :salt)<br>   (email<br>    :initarg :email :reader :email)<br>   (first-name<br>    :initarg :first-name :reader :first-name)<br>   (last-name<br>    :initarg :last-name :reader :last-name)<br>   (zip<br>    :initarg :zip :reader :zip)))</pre><br>Postmodern has a nice method for interacting with the database via class definitions that it coins "Database Access Objects". Note that DAOs neither are nor attempt to be a full ORM solution, a very sane decision in my humble and inexperienced opinion. Anyway, to make a normal class into a DAO class is easy, just do this:<br><pre lang="lisp">(defclass user ()<br>  ((username<br>    :col-type string<br>    :initarg :username :reader :username)<br>   (password<br>    :col-type string<br>    :initarg :password :reader :password)<br>   (salt<br>    :col-type string<br>    :initarg :salt :reader :salt)<br>   (email<br>    :col-type string<br>    :initarg :email :reader :email)<br>   (first-name<br>    :col-type string<br>    :initarg :first-name :reader :first-name)<br>   (last-name<br>    :col-type string<br>    :initarg :last-name :reader :last-name)<br>   (zip<br>    :col-type integer<br>    :initarg :zip :reader :zip))<br>  (:metaclass dao-class)<br>  (:keys username))</pre><br>All you have to do is add col-types to each slot so the system knows what type is stored in the database rows, list the components of the primary key and declare it a member of the dao-class metaclass. With that done, you can easily work with CLOS objects and fairly seamlessly select, update, delete or instantiate+insert them into the database. Creating the table itself can be done as follows: <code>(execute (dao-table-definition 'user))</code>. However, this is really intended as a shortcut for cases where you have a simple table definition.  Say you wanted to allowed users to own collections of things, maybe collectible cards, and track those in the database as well. You ought to have foreign key constraints on the database so that collections couldn't be owned by users that didn't exist or consist of cards that didn't exist or were made up.<br><br>In the case where foreign key constraints are desired or other more complex checks should be made, the preferred method is to write a deftable definition in addition to the class and then create the table with <code>(create-table 'class)</code> or <code>(create-all-tables)</code> if you have several tables. This <em>would</em> make for nasty code duplication since you'd still need a dao-object class to interact with the tables as nicely as possible. Thankfully, there's a macro to clear the situation up and import the simple parts from your dao-class specification. A possible deftable for the collection class might look like this:<br><pre lang="lisp">(deftable collection<br>  (!dao-def) ;; Import the existing info from the dao-class definition.<br>  (!foreign 'user 'username) ;; Ensure that the username that owns the collection exists in our user table.<br>  ;; Ensure that each card in a collection has a name and edition corresponding to a card in our database.<br>  (!foreign 'card '(card-name card-edition)<br>	          '(name edition)))</pre><br>Of course, if your tables are already created and you just want to access them or you want to create them at the psql prompt, you don't care about any of this. Hmm...I guess that's supposed to go at the top. Anyway, a more careful and thorough reading of the documentation would've shown me this but examples are nice and here one is in case anyone googles around for it like I did. As far as I can tell, this is the preferred current approach for table creation. Corrections welcome and thanks to Marijn Haverbeke for writing postmodern. It's been wonderful so far.
