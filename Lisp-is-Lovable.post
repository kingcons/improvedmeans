;;;;;
title: Lisp is Lovable
tags: LISP, Programming
date: 2009-05-27 15:59:11
format: html
;;;;;
I'm about to run to class but I thought I'd throw up a Lisp solution I coded to the Funny Words problem which <a href="http://blog.kingcons.io/posts/Playing-with-Haskell.html">I worked through in Haskell</a> earlier. I used <a href="http://www.sbcl.org/manual/Saving-a-Core-Image.html">sb-ext:save-lisp-and-die</a> thanks to <a href="http://mikael.jansson.be/log/freezing-lisp-in-time">a helpful guide</a> to dump a core image and used unix's <code>time</code> command to time it. The output of <code>time ./funnyWords.core english-words.txt</code> was as follows:<br>real	0m4.053s<br>user	0m3.913s<br>sys	0m0.057s<br><br>That's significantly shorter than the corresponding Haskell time and I wonder why. This code is a lot more imperative but I'm curious exactly where the speedups are. By the way, LOOP is awesome. As for the differences, I'll spend time sorting it out when I have time later. NOTE: solrize posted an improvement to my Haskell code that made it run in umm...half a second? Less? The main speedup seemed to be coming from using Data.Map and using the sort of each word as the key during insertion. That way, you get isAnagram for free, among other things. If you have thoughts on this code or the earlier Haskell code, where the differences lie or how to make them lispier or haskellier please let me know! :) Here's the code:<br><pre lang="lisp"><br>;; how to find words like cosmicomics:<br>;; words which can be split into anagrams by the middle letter<br>;; PRESENTLY ASSUME THAT ALL WORDS ARE LOWERCASE! how can we type/test for this?<br><br>(defparameter *dict* nil)<br>(defparameter *results* nil)<br>(defparameter *file* nil)<br><br>(defun main ()<br>  (let ((*file* (or (second *posix-argv*)<br>		    *file*)))<br>    (funny-words *file*))<br>  1)<br><br>(defun funny-words (wordlist)<br>  (let ((result nil))<br>    (with-open-file (in wordlist)<br>      (loop for word = (read-line in nil) while word do<br>	(push word result)))<br>    (setf *dict* result))<br>  (mapcar #'partial-find *dict*))<br>;;  (concat-map #'partial-find *dict*))<br><br>(defun is-anagram (word1 word2)<br>  (string= (sort (copy-seq word1) #'char-lessp)<br>	   (sort (copy-seq word2) #'char-lessp)))<br><br>(defun has-joiner (word1 word2)<br>  (let ((strlen (- (length word1) 1)))<br>    (char= (elt word1 strlen) (elt word2 0))))<br><br>(defun is-funny-word (word1 word2)<br>  (and (has-joiner word1 word2)<br>       (is-anagram word1 word2)<br>       (not (string= word1 word2))))<br><br>(defun build-word (word1 word2)<br>  (concatenate 'string word1 (subseq word2 1)))<br><br>(defun same-length (word lst)<br>  (loop for item in lst<br>	when (= (length word) (length item))<br>	  collecting item))<br><br>(defun partial-find (word)<br>  (loop for item in (same-length word *dict*)<br>	when (is-funny-word item word)<br>	  do (let ((answer (build-word item word)))<br>	       (push answer *results*)<br>	       (print answer))))<br><br>;;(defun concat-map (f lst)<br>;;  (loop for item in lst appending (funcall f item)))</pre>
