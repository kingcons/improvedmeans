;;;;;
title: A Common Lisp Web Development Primer, Part 1
tags: Linux, LISP, Programming
date: 2010-09-19 19:57:54
format: html
;;;;;
<strong>Disclaimer Pt.1</strong>: There are many people smarter and more qualified than me when it comes to CL web development. Thankfully, this article is covering basics and my knowledge should be sufficient. Correct me where wrong, of course.<br><strong>Disclaimer Pt.2</strong>: This article will deal more with config files, programming environment setup and the CL web dev landscape with a follow up article to introduce a specific framework, examples, etc.<br><strong>Edit of Nov 12, 2010</strong>: This article has been updated to reflect modern Common Lisp best practices (i.e. <a href="http://quicklisp.org/">Quicklisp</a>).<br><h3>The Hardware</h3><br>The first thing to talk about is where our application will be served. This was recently <a href="http://www.reddit.com/r/lisp/comments/d7rlx/ask_rlisp_do_any_cl_implementations_work_well_on/">discussed on lisp.reddit</a>. Unlike languages like PHP, Perl, Ruby or Python, shared hosting is not prevalent for lisp though <a href="http://www.tech.coop">tech.coop</a> is a notable exception. In general, a VPS or similar setup will be required. I've heard good things about people using <a href="http://www.slicehost.com/">Slicehost</a>, <a href="http://www.linode.com/">Linode</a> and <a href="http://www.thrustvps.com/">ThrustVPS</a>. Personally, I use Linode's smallest instance for $20 a month and have been quite happy with it. I've run hunchentoot, lighttpd, postgres and mysql on it simultaneously without issue but that wasn't under significant load. I'm also aware of at least one startup using Lisp on top of <a href="http://aws.amazon.com/ec2/">Amazon's EC2</a>. Heck, you may have a server you'd like to run out of your home. For our purposes, I will assume you have a reliable internet-facing Linux box and root access.<br><h3>The Linux Distro and Programs</h3><br>Any Linux distribution should be suitable for lisp web server duties. Personally, I would lean towards <a href="http://www.archlinux.org/">Archlinux</a> as their default install is quite lean and they keep very recent versions of SBCL(1.0.42), CMUCL(20a) and others packaged. There's even a <a href="http://aur.archlinux.org/packages.php?ID=25565">CCL AUR package</a> (<a href="http://wiki.archlinux.org/index.php/Arch_User_Repository">Archwiki AUR article</a>) maintained by <a href="http://blog.viridian-project.de/">Leslie Polzer</a>. Whatever distribution you wind up using to follow along with this series I recommend you also install screen, emacs, sbcl and lighttpd with your package manager. You should also grab the VCS pentafecta of darcs, git, mercurial, subversion and cvs.<br><h3>Setting up Emacs and SLIME</h3><br>Note that there are many other, probably better, Emacs+SLIME tutorials out there. Since the original writing of this article, Quicklisp has become the dominant method for acquiring Common Lisp libraries. Instructions for its use are here and the clbuild instructions are maintained below for posterity. First grab quicklisp with <code>curl -O http://beta.quicklisp.org/quicklisp.lisp</code> then load and install it by running <code>sbcl --load quicklisp.lisp,</code> followed by evaluating <code>(quicklisp-quickstart:install)</code>, <code>(ql:add-to-init-file)</code> and <code>(ql:quickload "quicklisp-slime-helper")</code>. Finally, add <code>(setq inferior-lisp-program "sbcl")</code> and <code>(load (expand-file-name "~/quicklisp/slime-helper.el"))</code> to your ~/.emacs.<br><p style="padding-left: 30px;"><strong>Alternate clbuild instructions</strong><br>The first thing to do is grab clbuild. At least until <a href="http://www.quicklisp.org/">quicklisp</a> is released, clbuild will remain the easiest way to get all the necessary lisp libraries to get cranking on web development in linux. I like to keep clbuild in ~/builds but place it where you like. Download it with <code>darcs get http://common-lisp.net/project/clbuild/clbuild</code>. Then cd into the clbuild directory and make it executable by running <code>chmod +x clbuild</code>. I'd also add the directory to your path in .bashrc or add an alias like <code>alias clbuild='/home/redline/builds/clbuild/clbuild'</code>.</p><br><p style="padding-left: 30px;">With that done, it's time to start grabbing libraries. First, get <a href="http://common-lisp.net/project/slime/">SLIME</a> by running <code>clbuild update slime</code>. Then you'll want to run <code>clbuild slime-configuration</code> and stick that in your ~/.emacs file, taking care to change the <code>(setq inferior-lisp-program "/home/.../.../clbuild/clbuild lisp")</code> to <code>(setq inferior-lisp-program "sbcl")</code> or "/usr/bin/sbcl" or whatever is appropriate.<br><strong>End clbuild-specifics</strong></p><br>At this point you should be able to ssh into your development server, run emacs -nw (for no-window-system/terminal mode) and then type M-x (alt-x) slime and enter to get to a lisp prompt.<br><h3>Getting the Lisp Libraries</h3><br>After talking with Leslie a bit, I'll be using weblocks-dev over weblocks-stable. Weblocks-dev use is encouraged over stable at this time. Quicklisp uses weblocks-dev already and makes this insanely easy, just evaluate <code>(ql:quickload 'weblocks)</code>. Done.<br><p style="padding-left: 30px;"><strong>clbuild specifics</strong><br>If you'd like to use weblocks-dev, open /path/to/your/clbuild/wnpp-projects in your favorite text editor and change the following:<br>1) Find elephant and change it's darcs repo from blah/blah/blah/elephant to blah/blah/blah/elephant-1.0<br>2) Find weblocks and change it's hg repo from http://www.bitbucket.org/skypher/weblocks-stable/ to http://www.bitbucket.org/S11001001/weblocks-dev/<br>3) Find cl-prevalence and change it's repo to cl-prevalence get_hg http://www.bitbucket.org/skypher/cl-prevalence/<br>Then run <code>clbuild update weblocks</code> and, if prompted about whether or not to download dependencies, enter 'y'. Let it work it's most excellent magic.<br><strong>End clbuild-specifics</strong></p><br><br><h3>The Framework Selection</h3><br>There are a multitude of ways to do web development in Common Lisp. There are web servers such as <a href="http://www.cliki.net/araneida">Araneida</a> and <a href="http://www.cliki.net/AllegroServe">Portable Allegroserve</a> (both effectively unmaintained), <a href="http://weitz.de/hunchentoot/">Hunchentoot</a> (which is dominant in the way *Ediware* often is), Apache with <a href="http://www.cliki.net/mod_lisp">mod_lisp</a>, relatively obscure or undocumented combination server/frameworks like <a href="http://hoytech.com/antiweb/">Antiweb</a>, <a href="http://github.com/lnostdal/SymbolicWeb">Symbolicweb</a>/<a href="http://github.com/lnostdal/SW-HTTP">SW-HTTP</a> and <a href="http://github.com/vii/teepeedee2">Teepeedee2</a> and frameworks like <a href="http://weblocks.viridian-project.de/">Weblocks</a>, <a href="http://common-lisp.net/project/ucw/">UCW</a> and <a href="http://www.cliki.net/RESTAS">RESTAS</a>.<br><br>I wanted something relatively commonly used and well-documented but I wanted a framework as opposed to just using libraries like CL-WHO, Parenscript and Postmodern on top of hunchentoot. Since <a href="http://ifelipe.net/">UCW already has a blog series</a> and I've worked with Leslie on <a href="http://github.com/redline6561/paktahn">Paktahn</a> a while, Weblocks was a natural choice for me.<br><h3>The App Setup</h3><br>I already run a wordpress blog and some other stuff on a lighttpd server on my Linode. Consequently, it made sense to just map a subdomain to my lisp experiments and leave the rest alone. To do this with lighttpd, add the following to /etc/lighttpd/lighttpd.conf:<br><pre lang="lua">$HTTP["host"] =~ "testbed.redlinernotes.com" {<br>              proxy.server = ( "/" => ( ( "host" => "127.0.0.1",<br>                                          "port" => 4242 ) ) )<br>}</pre><br>Now you wouldn't want your webapp to not restart if you had to reboot the server would you? Of course you wouldn't. I've <a href="http://xach.livejournal.com/215066.html">taken a cue from Xach</a> and daemonized it via screen as follows:<br>Open /etc/rc.local in your favorite text editor and insert a line similar to <code>su redline -c 'screen -d -m -S screenslime -c /home/redline/webapps/screenrc'</code>. This will ensure that the redline user starts a screen instance in detached mode with the name "screenslime" when the system boots that will use /home/redline/webapps/screenrc as it's configuration. If you don't know what any of that means, don't worry. It means screen is cool and you want it.<br><br>Now, you should add something like the following to whatever file you listed as your screenrc:<br><pre>chdir /home/redline/projects<br><br>screen emacs -nw<br>screen sbcl --userinit /home/redline/.sbclrc --load /home/redline/webapps/init.lisp</pre><br>This will ensure screen defaults to the /home/redline/webapps directory, starts an emacs instance in no-window-systems mode in screen window 0 and starts sbcl loading your .sbclrc and a lisp init script for your webapp(s) in screen window 1.<br><br>Next, we need to actually write the init file for your webapp. For now, it will be quite simple as I'm just playing with weblocks. In the next article, we'll build something (probably un) interesting. In your init.lisp file (or whatever you called it) insert something like:<br><pre lang="lisp">(ql:quickload '(weblocks swank))<br><br>(setf swank-loader::*contribs* '(swank-c-p-c swank-arglists<br>                                 swank-fuzzy swank-fancy-inspector<br>                                 swank-package-fu))<br>(swank-loader::loadup)<br>(swank:create-server :dont-close t<br>                     :port 4010<br>                     :coding-system "utf-8-unix")</pre><br>This will ensure weblocks loads and swank serves on port 4010 so that we can use SLIME to connect and work on the running system. Note that you could've also put <code>(load "/path/to/my/.sbclrc")</code> or inlined the following as the first line(s) in your init file and avoided the --userinit portion of the sbcl invocation in screenrc. My .sbclrc simply points sbcl to the clbuild libraries like so:<br><pre lang="lisp">(require 'asdf)<br>(setf asdf:*central-registry* '("/home/redline/clbuild/systems" *default-pathname-defaults*))</pre><br>Unless you're using clbuild, you won't need this in your .sbclrc but if you are it's important that you do this so that sbcl can find the lisp libraries we downloaded with clbuild. If you don't, it'll be looking in ~/.sbcl/systems.<br><br>Finally, I would also add a bash alias to your ~/.bashrc to get you right back to where you were with screen+SLIME. Mine is <code>alias webslime='screen -dR'</code>. I also added <code>stty -ixon</code> to my .bashrc as detailed in <a href="http://blog.kingcons.io/posts/A-short-update-and-emacsscreen-note.html">my last post</a> because screen was capturing keystrokes I wanted sent to emacs. Xach pointed out that this could be toggled in screen with C-a C-f but I preferred having it as a default.<br><br>See, now that was mostly painless, wasn't it? Next time I'll cover the basics of weblocks and develop a simple starter application. Or if I'm feeling particularly lazy, maybe I'll just walk us through the simple-blog example-app. Cheers.
