;;;;;
title: A Common Lisp Web Development Primer, Part 2
tags: LISP, Programming
date: 2010-11-16 03:19:24
format: html
;;;;;
<strong>Disclaimer</strong>: This blog will not teach you Common Lisp. That is a (mostly) solved problem. See Peter Seibel's <a href="http://gigamonkeys.com/book/">Practical Common Lisp</a> and Peter Norvig's <a href="http://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910/ref=pd_sim_b_3">PAIP</a>. Other oft-recommended texts include Keene's <a href="http://www.amazon.com/Object-Oriented-Programming-Common-Lisp-Programmers/dp/0201175894/ref=pd_bxgy_b_text_b">OOP in CLOS</a>, PG's <a href="http://www.paulgraham.com/onlisp.html">On Lisp</a> and Kiczales et al's <a href="http://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744">The Art of the Metaobject Protocol</a>. This blog will also not teach you good style, I'm too young for that. It hopefully demonstrates non-atrocious style though. I'm learning web development as I go, so don't count on expert understanding there either.<br><strong>Disclaimer Pt. 2</strong>: For the foreseeable future all these projects will be weblocks-based. If that's not your cup of tea you can check out the <a href="http://restas.lisper.ru/en/index.html">RESTAS docs and examples</a>, <a href="http://ifelipe.net/">Felideon's blog on UCW</a>, <a href="http://www.adampetersen.se/articles/lispweb.htm">Adam Petersen's slightly bitrotted sans framework article</a> or "defect" to Clojure and look at all the <a href="http://github.com/weavejester/compojure">Compojure</a> stuff and maybe <a href="http://github.com/brentonashworth/sandbar">Sandbar</a>.<br><h3>Introduction</h3><br>It's taken far longer than I hoped to get this second article off the ground. For those of you who missed Part 1, <a href="http://redlinernotes.com/blog/?p=1232">look here</a> and if you'd rather see code than this article's commentary, the code is available <a href="http://github.com/redline6561/clockwork/">on github</a>. It's worth noting that Part 1 was originally written with clbuild in mind but has since been updated with instructions for quicklisp also. Part 2 details the construction of <a href="http://clockwork.redlinernotes.com/">Clockwork</a>, a simple clone of the now defunct <a href="http://www.viddler.com/molzy/videos/72/">yourli.st</a>, an email reminder service. Clockwork allows you to schedule a reminder and brief note which is sent to you by email or text message at the predetermined time. Right now international numbers aren't supported but I'd be happy to see patches.<br><h3>Future Plans</h3><br>There's still a good amount of stuff in the <a href="http://github.com/redline6561/clockwork/blob/master/TODO">TODO</a> and I have further projects in mind after this. Part of the reason this article was so long in coming is that I've been helping Leslie by testing out his new form-widget library. The other reasons are that I have school and (until recently) was working plus I'm learning web development as I go. The next article will go into polishing this application and will likely be much more Javascript and CSS than Lisp. I'm working on getting a <a href="http://marijnhaverbeke.nl/postmodern/">postmodern</a> backend written, tested and merged into Weblocks right now. Once that's done I plan to continue this series by developing a RESTful blog that can import entries from Wordpress and maybe crosspost to livejournal as that should prove more interesting...but like Linus' said, "Talk is cheap, show me the code".<br><h3>Resources, Libraries and Project Skeleton</h3><br>Weblocks docs are not in an ideal state and hopefully this blog series will help that some. Four things worth being aware of for a beginner are the <a href="http://groups.google.com/group/weblocks">Google group</a>, the <a href="http://viridian-project.de/~sky/weblocks-stable/docs/gen/weblocks-package/index.html">TINAA-generated docs</a>, the <a href="http://trac.common-lisp.net/cl-weblocks/wiki/UserManual">User Manual</a> and <a href="http://viridian-project.de/~sky/user-guide.stx.html">User Guide</a>. As usual, googling specific concepts will lead you to blog entries and mailing list posts that may or may not be out of date.<br><br>We'll begin by using weblocks helper to create a project skeleton by evaluating <code>(wop:make-app 'clockwork "/home/redline/projects/")</code>. If you've been following along since Part 1, you'll also want to push that path onto the ASDF central registry so you can use quicklisp to load the clockwork system in your server init file (<code>~/webapps/init.lisp</code>). <code>(push "/home/redline/projects/clockwork/" asdf:*central-registry*)</code> will do the trick. Then add a <code>(ql:quickload '(clockwork))</code> line at the bottom of the file followed by <code>(clockwork:start-clockwork :port 4242)</code>. At this point, you should be able to reboot the server and run <code>screen -dRR</code> or similar to get a screen session with emacs and an sbcl instance with clockwork and swank running. They'll be in different windows which you can switch to with C-a (control-a) and the window number. Numbers start at 0. Enough of that, this isn't a GNU Screen tutorial. Go to the emacs instance and run M-x slime-connect making sure to change the port to that specified in the init file. At this point, you're connected to SLIME and can evaluate <code>(in-package :clockwork)</code> and finally get hacking! You should also be able to reach clockwork in the browser at localhost:4242 but there's not much there yet...<br><br>To begin with, you'll need some libraries to send emails and schedule reminders to be sent in the future. <a href="http://www.sbcl.org/manual/Timers.html">SBCL provides a Timers facility</a> which we could use for this but it's usually worth doing a little extra work to write portable Common Lisp. To this end we'll use the <a href="http://www.cliki.net/trivial-timers">trivial-timers</a> library as a wrapper and <a href="http://common-lisp.net/project/cl-smtp/">cl-smtp</a> for emails. We'd also like to handle timezones and time arithmetic properly so we'll use the <a href="http://common-lisp.net/project/local-time/">local-time</a> library for that. We'll also be doing some minor string handling which <a href="http://www.cliki.net/SPLIT-SEQUENCE">split-sequence</a> winds up being an easy solution for so grab that too. Add those to the <code>:depends-on</code> clause in clockwork.asd in the project directory and then run <code>(ql:quickload 'clockwork)</code> at the REPL. Quicklisp will download and load the new libraries for you. It's that easy. Finally, add <code>:local-time</code> to the <code>:use</code> clause of the defpackage in clockwork.lisp and import the split-sequence symbol from the split-sequence package.<br><h3>Data and Weblocks Stores</h3><br>By default Weblocks defines a <a href="http://common-lisp.net/project/cl-prevalence/">cl-prevalence</a> backend ("store") which persists data to the "data/" directory in the clockwork project folder. The store itself is defined in conf/stores.lisp and that's where you would go to define additional stores if you wanted them. Weblocks has a special variable, *default-store*, and DEFSTORE sets that variable after defining a store so the last store defined in stores.lisp will act as the default. Weblocks also supports <a href="http://common-lisp.net/project/elephant/">elephant</a> and <a href="http://clsql.b9.com/">clsql</a> but for now, we'll focus on other aspects of the framework and delve more into the Store API in a later article. If you're curious now though the <a href="http://bitbucket.org/S11001001/weblocks-dev/src/tip/src/store/store-api.lisp">Store API is clearly defined and documented</a>.<br><br>The only data we really care about is the reminders our users will generate. For our purposes, a reminder consists of some number of recipients, a title, a summary of the event it's reminding you of, the time of the event and how far before the event you'd like to be reminded. A class definition falls out of this rather naturally and we'll add an id slot so prevalence will know how to store it. Create a src/reminder.lisp file, insert the following and add the file to the :components clause of clockwork.asd.<br><br><pre lang="lisp"><br>(in-package :clockwork)<br><br>(defclass reminder ()<br>  ((id :reader reminder-id) ;; all classes to be persisted with cl-prevalence need an id slot<br>   (emails :reader reminder-emails<br>           :initarg :emails<br>           :type list)<br>   (title :reader reminder-title<br>          :initarg :title<br>          :type string)<br>   (timestamp :reader reminder-timestamp<br>              :initarg :timestamp<br>              :type timestamp)<br>   (summary :reader reminder-summary<br>            :initarg :summary<br>            :type string)<br>   (at :reader reminder-at<br>       :initarg :at<br>       :type timestamp)))<br></pre><br>Now that we have a rough idea of what data we care about, lets look at how to send messages.<br><h3>Emails and Text Messaging</h3><br>Text messaging is actually quite simple to support thanks to the <a href="http://en.wikipedia.org/wiki/List_of_SMS_gateways">SMS gateways</a> run by the major carriers. SMS gateways allow us to send an email to an address which represents a phone number. This is then converted to a text message and forwarded on to the recipient's cell phone free of charge. The downside to this is that it's carrier specific so you have to know the cell carrier of the recipient. It would be nicer to just take a number and figure out what carrier services it but <a href="http://en.wikipedia.org/wiki/Local_number_portability">Local Number Portability</a>, among other things, makes this tricky. Whitepages.com has an API for looking this up but their information was out of date for my cell phone and they had a 200 request per API key per day limit. <a href="http://www.twilio.com/">Twilio</a> and <a href="http://data24-7.com/">Data24-7</a> offer for-pay APIs but for this example app I'll be staying free and cheap. I'll be coldly forcing my users to select their carrier from a dropdown if they want SMS support.<br><br>Since we don't know whether our users really care about their privacy or what kind of data they'll be putting in these reminders, we'll do the responsible thing and send the emails via Encrypted SMTP. I'll be using a gmail account I registered for the service since Google provides free, encrypted SMTP on all their accounts. Let's write a quick helper macro for using it. Create a src/messaging.lisp file, insert the following and add it to the :components clause of clockwork.asd.<br><br><pre lang="lisp"><br>(in-package :clockwork)<br><br>(defparameter *mail-server* "smtp.gmail.com")<br><br>(defmacro with-encrypted-smtp ((&key to subject style<br>                               (from "cl.ockwork.webdev@gmail.com"))<br>                               &body body)<br>  `(cl-smtp:send-email ,*mail-server* ,from ,to ,subject<br>                       (if (eql ,style :html)<br>                           (with-html ,@body) ;; TODO: make a nicer render style<br>                           ,@body)<br>                       ;; it's worth noting send-email takes a :cc argument<br>                       :ssl :tls<br>                       :authentication '(,*smtp-user* ,*smtp-pass*)<br>                       ,@(when (eql style :html)<br>                               '(:extra-headers<br>                                 '(("Content-type"<br>                                    "text/html; charset=\"iso-8859-1\""))))))<br></pre><br>Note that we haven't defined *smtp-user* or *smtp-pass* yet. There are two questions you should be asking. Why a macro and what is it doing? The why is debatable in this case. I wanted the syntax to jump out at me and read a certain way when I use the encrypted SMTP. That's all. The what is fairly straightforward. The macro is syntactically similar to with-open-file and others. It takes keyword arguments for the recipient, sender (with a default value), subject and style of the message along with a message as the body and then sends an email via encrypted SMTP (and cl-smtp's send-email function) with the credentials provided. If the style is :html, it goes to the trouble of specifying a few additional headers.<br><br>Since we haven't defined the user and pass, let's do that now. Create a conf/config.lisp file, insert the following and add it to your clockwork.asd.<br><pre lang="lisp"><br>(in-package :clockwork)<br><br>(defparameter *smtp-user* "yourusername@gmail.com")<br>(defparameter *smtp-pass* "yourpassword")<br></pre><br>Obviously, you don't want this puppy in source control. Consequently,  I committed it before I filled in the user and pass values then ran <code>git update-index --assume-unchanged conf/config.lisp</code> which tells git to ignore all future changes to the file. Be forewarned, that command might be reversible but I don't know how. Go ahead and add in your username and password, reload the system at the REPL with <code>(ql:quickload 'clockwork)</code> and test it out. You should be able to send yourself an email. Now let's add some helpers for SMS. Return to the src/messaging.lisp file and we'll add a variable defining a mapping of Carriers to SMS Gateway servers and a function for determining if an email address belongs to one of the listed SMS gateways. Add the following code to the bottom of the file.<br><pre lang="lisp"><br>(defparameter *sms-gateways*<br>  ;; list is derived from http://en.wikipedia.org/wiki/List_of_SMS_gateways<br>  '(("AT&T/Cingular" . "txt.att.net")<br>    ("Alltel" . "text.wireless.alltel.com")<br>    ("Boost Mobile" . "myboostmobile.com")<br>    ("Cincinatti Wireless" . "gocbw.com")<br>    ("MetroPCS" . "mymetropcs.com")<br>    ("Sprint/PCS" . "messaging.sprintpcs.com")<br>    ("Sprint/Nextel" ."page.nextel.com")<br>    ("T-Mobile" . "tmomail.net")<br>    ("US Cellular" . "email.uscc.net")<br>    ("Verizon" . "vtext.com")<br>    ("Virgin Mobile" . "vmobl.com")))<br><br>(defun sms-mail-p (email)<br>  (let ((domain (second (split-sequence #\@ email))))<br>    (member domain *sms-gateways* :key #'cdr :test #'equal)))<br></pre><br><br><h3>A Few Reminder Methods</h3><br>We still need methods to send a reminder, delete it when we're through with it and schedule it to be sent at a later time. Let's create those now. Since users aren't required to register to send a reminder, we'll put off letting them delete reminders from the system for now. When they submit the reminder form, a reminder will be instantiated, persisted and scheduled for later sending and deletion. We'd like to offer the user the ability to send reminders by email, text message or both so we'll assume that a list of emails are stored in the emails slot of the reminder and loop through each one, sending it with the macro we defined earlier. Then we'll use Weblocks Store API to delete the object from the datastore. Add the following code to the end of src/reminder.lisp.<br><pre lang="lisp"><br>(defgeneric send-and-delete (reminder)<br>  (:documentation "Send the user their reminder as requested and then remove it from the datastore."))<br><br>(defmethod send-and-delete ((reminder reminder))<br>  (loop for email in (reminder-emails reminder) do<br>    (with-encrypted-smtp (:to email :subject (reminder-title reminder)<br>                              :style (if (sms-mail-p email)<br>                                         :plain<br>                                         :html))<br>      (reminder-summary reminder)))<br>  (delete-persistent-object-by-id *default-store* 'reminder (reminder-id reminder)))<br></pre><br><br>Finally, we'd like to schedule the reminder to be sent at a later date. Assuming that the timezone differences are handled beforehand and that the reminder's at slot contains a timestamp for when the message should be sent according to the server's timezone, the local-time and trivial-timer libraries make defining a schedule method pretty easy. We'll just use the local-time library and a let to compute the seconds from the present until the time to send the reminder, make a timer whose function calls send-and-delete on the reminder and schedule it with a delay of the number of seconds computed. The only tricky bit is to pass :thread t to make-timer so that each timer is triggered in a new thread. If this isn't done, the timer will try to interrupt an arbitrary thread to run it's function which, put plainly, is unreliable. Another alternative would be to have a dedicated thread for sending reminders and pass that as the argument to :thread but we'll take the easy way out this time. Add the following code to the end of reminder.lisp. Here are links to my versions of the files: <a href="https://github.com/redline6561/clockwork/blob/master/src/messaging.lisp">messaging</a>, <a href="https://github.com/redline6561/clockwork/blob/master/src/reminder.lisp">reminder</a>.<br><br><pre lang="lisp"><br>(defgeneric schedule (reminder)<br>  (:documentation "Schedule the reminder to be sent at the time the user requested."))<br><br>(defmethod schedule ((reminder reminder))<br>  (let ((secs-until-reminder (round (timestamp-difference (reminder-at reminder) (now)))))<br>    (trivial-timers:schedule-timer<br>     (trivial-timers:make-timer (lambda ()<br>                                  (send-and-delete reminder)) :thread t)<br>     secs-until-reminder)))<br></pre><br><br><h3>Next Time...</h3><br>This article got long. It may be too high-level for some, too low-level for others and too wordy for everybody. In addition, this isn't the most thrilling software ever constructed. Next time we'll get into more Weblocks specifics and work on the frontend to get the form and a jQuery calendar up and going. Please let me know if there are questions I can answer, things you'd like covered in more depth or other thoughts on how to improve this series. Thanks for reading.
