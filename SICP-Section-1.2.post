;;;;;
title: SICP Section 1.2
tags: LISP, Self-Learning, SICP
date: 2008-02-29 19:39:36
format: html
;;;;;
<p>I finally finished SICP Section 1.2 last night. I'm tremendously excited because this means that next week I can start tackling <a href="http://en.wikipedia.org/wiki/Higher-order_function">Higher Order Functions</a> and (I hope) <a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">Closures</a>. At any rate, here is the last month's work:</p><br><p><!--more--></p><br><p>Resources:<br /><br>Read: <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-9.html#%_chap_1" title="Start">Chapter 1</a> through <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html" title="Finish">Section 1.2</a><br /><br>Watch: <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/" title="Lectures">Lectures</a> <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/videos/Lecture-1b.avi">1-b</a><br /><br>Checked against: <a href="http://eli.thegreenplace.net/category/programming/lisp/sicp/">Eli Bendersky's Blog</a>, <a href="http://sicp.org.ua/sicp/Section1-2">SICP Wiki</a>, <a href="http://www.kendyck.com/solutions-to-sicp/">Ken Dyck's Solutions</a>, <a href="http://www.michaelharrison.ws/weblog/?p=47">Autodidact</a> and <a href="http://lispy.wordpress.com/2007/09/22/mastering-higher-order-programming-techniques-with-sicp-chapter-1/">Lispy</a> for Inspiration.</p><br><p>SICP Notes and Exercises:</p><br><p>Notes<br /><br>Pg. 35: Explanations of Iteration and Recursion in Processes and Procedures and Tail-Recursion in Compilers.</p><br><p>Maybe I was wrong about SICP. I mean the hardest thing about these exercises was letting the stuff sit in my head for a bit. And the motivation to get some of the more lengthy ones done. We'll see how this goes.</p><br><p>Quotes<br /><br>"A recursive definition does not necessarily lead to a recursive process." - Gerald Jay Sussman, SICP Lecture 1-B's Time-Space Complexity explanation, approx. 25:30 - 30:30</p><br><p>"The key to understanding complicated things is knowing what not to look at." - Gerald Jay Sussman, SICP Lecture 1-B from Swiss Archive, approx. 10:00</p><br><p>"The reason why people think of programming as being hard is because you're writing down a general rule which is going to be used for lots of instances that a particular instance must process correctly." - Gerald Jay Sussman, SICP Lecture 1-B from Swiss Archive, approx. 46:45</p><br><p>Exercises<br /><br><a href="http://sicp.org.ua/sicp/Exercise1-9">1.9</a>:<br /><br>The first procedure evaluates as follows:</p><br><pre lang="lisp"><br>(inc (+ 3 5))<br>(inc (inc (+ 2 5)))<br>(inc (inc (inc (+ 1 5))))<br>(inc (inc (inc (inc (+ 0 5)))))<br>(inc (inc (inc (inc 5))))<br>(inc (inc (inc 6)))<br>(inc (inc 7))<br>(inc 8)<br>9</pre><br><p>This is a recursive procedure and a recursive process.</p><br><p>The second procedure evaluates as follows:</p><br><pre lang="lisp"><br>(+ 3 6)<br>(+ 2 7)<br>(+ 1 8)<br>(+ 0 9)<br>9</pre><br><p>This is a recursive procedure but an iterative process.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-10">1.10</a>:<br /><br>(A 1 10) evaluates as follows:</p><br><pre lang="lisp"><br>(A 0 (A 1 9))<br>(A 0 (A 0 (A 1 8)))<br>(A 0 (A 0 (A 0 (A 1 7))))<br>(A 0 (A 0 (A 0 (A 0 (A 1 6)))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 32)))))<br>(A 0 (A 0 (A 0 (A 0 64))))<br>(A 0 (A 0 (A 0 128)))<br>(A 0 (A 0 256))<br>(A 0 512)<br>1024</pre><br><p>(A 2 4) evaluates as follows:</p><br><pre lang="lisp"><br>(A 1 (A 2 3))<br>(A 1 (A 1 (A 2 2)))<br>(A 1 (A 1 (A 1 (A 2 1))))<br>(A 1 (A 1 (A 1 2)))<br>(A 1 (A 1 (A 0 (A 1 1))))<br>(A 1 (A 1 (A 0 2)))<br>(A 1 (A 1 4))<br>(A 1 (A 0 (A 1 3)))<br>(A 1 (A 0 (A 0 (A 1 2))))<br>(A 1 (A 0 (A 0 (A 0 (A 1 1)))))<br>(A 1 (A 0 (A 0 (A 0 2))))<br>(A 1 (A 0 (A 0 4)))<br>(A 1 (A 0 8))<br>(A 1 16)<br>(A 0 (A 1 15))<br>(A 0 (A 0 (A 1 14)))<br>(A 0 (A 0 (A 0 (A 1 13))))<br>(A 0 (A 0 (A 0 (A 0 (A 1 12)))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))<br>(A 0 (A 0 (A 0 (A 0 (A 0 2048)))))<br>(A 0 (A 0 (A 0 (A 0 4096))))<br>(A 0 (A 0 (A 0 8192)))<br>(A 0 (A 0 16384))<br>(A 0 32768)<br>65536</pre><br><p>(A 3 3) evaluates as follows:</p><br><pre lang="lisp"><br>(A 2 (A 3 2))<br>(A 2 (A 2 (A 3 1)))<br>(A 2 (A 2 2))<br>(A 2 (A 1 (A 2 1)))<br>(A 2 (A 1 2))<br>(A 2 (A 0 (A 1 1)))<br>(A 2 (A 0 2))<br>(A 2 4)<br>65536</pre><br><p>(see evaluation of (A 2 4) above)</p><br><p>The defined procedures f, g, and h intriguingly map as follows:<br /><br>(f n) -> (* 2 n)<br /><br>(g n) -> 2^n<br /><br>(h n) -> 2 raised to itself, n times.</p><br><p>##NOTE:<br /><br>In the book examples are given of recursive and iterative ways to compute the fibonacci sequence. However, the example given for the fibonacci sequence computes a term beyond what is desired to arrive at it's final answer. The termination condition is count = 0 at which point b is returned. This is a small change to that program to fix what I perceive as a flaw. Have I missed something?<br /><br>My version returns a when count = 1.</p><br><pre lang="lisp"><br>(define (fib n)<br>  (fib-iter 1 0 n))<br>(define (fib-iter a b count)<br>  (if (= count 1)<br>      a<br>      (fib-iter (+ a b) a (- count 1))))</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-11">1.11</a>:<br /><br>A tree recursive process that computes f is demonstrated in the following procedure:</p><br><pre lang="lisp"><br>(define (f n)<br>  (cond ((< n 3) n)<br>	   ((or (= n 3) (> n 3))<br>            (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))))</pre><br><p>An iterative process that computes f is demonstrated in the following procedure:</p><br><pre lang="lisp"><br>(define (f n)<br>  (f-iter 2 1 0 n))<br><br>(define (f-iter a b c count)<br>  (cond ((< count 3) count)<br>	(else (f-iter (+ a (* 2 b) (* 3 c)) a b (- count 1)))))</pre><br><p>Figuring out the iterative process was scary. It was the first moment I thought I wouldn't be able to do this and might need real help. I was unsure of whether I needed three or four state variables. It clicked after a few minutes of thinking though and was much smoother from there.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-12">1.12</a>:<br /><br>This one actually gave me some trouble for a bit because I wanted to solve the problem in a non-standard way. After a while, I cracked and read the precursor text (but not the code) to <a href="http://eli.thegreenplace.net/2007/06/28/sicp-section-122/">Eli Bendersky's solution</a> and noticing that he defined the function with two arguments (for columns and rows) arrived fairly quickly with that insight at what seems to be the more or less standard solution. I had this much completed for a week or more but got stalled trying to figure out the problem of a pascal function that takes one argument. That diversion contributed greatly to the delay in my progress. I <a href="http://www.redlinernotes.com/blog/?p=866">did solve it though</a> and posted the results separately. Here's the standard solution:</p><br><pre lang="lisp"><br>(define (pas row col)<br>  (cond ((= row 1) 1)<br>	((= col 1) 1)<br>	((= row col) 1)<br>	(else (+ (pas (- row 1) (- col 1))<br>		 (pas (- row 1) col)))))<br>;Value: pas</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-13">1.13</a>:<br /><br>I need to define a few things for this one first.<br /><br>rad = the square root of 5 or</p><br><pre lang="lisp">(sqrt 5)</pre><br><p>phi = (1 + rad) / 2 or</p><br><pre lang="lisp">(/ (+ 1 rad) 2)</pre><br><p>psi = (1 - rad) / 2 or</p><br><pre lang="lisp">(/ (- 1 rad) 2)</pre><br><p>fib = you remember our fibonacci function from before right? That's all this is.</p><br><p>Prove that Fib(n) is the closest integer to (/ (phi ^ n) rad). Hint: Use psi as defined above, induction and the definition of the Fibonacci numbers to prove that Fib(n) = ((phi ^ n) - (psi ^ n)) / rad.</p><br><p>Okay, this one is intimidating for a number of reasons. One being that I've never done a formal proof before. At least that I can remember. I've seen proofs done and I've read one or two but I've never done one. Either my math education was lax or I was lax about my math education. In fairness, it was probably a bit of both. That unfamiliarity combined with the aforementioned pascal with a single argument problem served to keep me unmotivated and distracted for a bit.</p><br><p>Prove: That Fib(n) = ((phi ^ n) - (psi ^ n)) / rad.<br /><br>First, you have to prove your base cases.</p><br><p>Fib (0) = ((phi ^ 0) - (psi ^ 0)) / rad.<br /><br>That reduces to, 0 = (1 - 1) / rad, So the first base case holds.</p><br><p>Fib (1) = ((phi ^ 1) - (psi ^ 1)) / rad.<br /><br>That reduces to, 1 = ((1 / 2) + (rad / 2) - (1 / 2) + (rad / 2)) / rad.<br /><br>That reduces to, 1 = rad / rad, so the second base case holds.</p><br><p>The definition of Fibonacci numbers is that fib(n) = fib(n-1) + fib(n-2) so fib(2) = 0 + 1 = 1. Having found that our lemma is true for n-1 and n-2 will it hold for n?</p><br><p>Fib (2) = ((phi ^ 2) - (psi ^ 2)) / rad.<br /><br>Remembering that Phi is the golden ratio it meets the condition that (phi ^ 2) = phi + 1.<br /><br>This gives fib (2) = (2.61803398 - 0.38196601) / rad.<br /><br>This reduces to fib (2) = 2.23606797 / rad giving 1.</p><br><p>Thus, our lemma holds for fib(n). This does not explain how Fib(n) is always the closest integer to phi ^ n / rad though.</p><br><p>To explain that we must note that in the base case of 1 it holds as phi ^ n / rad evaluates to 0.723606798 and Fib(1) is 1. So, it holds here.<br /><br>We may then observe that psi being less than 1 will always approach zero as it's exponent is increased.<br /><br>Thus, the difference between the fib(n) and (/ (phi ^ n) rad) will always be less than 0.381 for n >= 2.<br /><br>This is what we needed to show.</p><br><p>Whew. After checking this against other people's solutions it turns out I'm not crazy and am roughly correct in my proof which is a relief.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-14">1.14</a>:<br /><br>Okay. I drew the tree on paper but trying to draw this tree in ASCII for you guys would about kill me. Thankfully on checking my solution I was lucky to find a correct tree image which I will steal with credit. Thanks, <a href="http://www.kendyck.com/archives/2005/04/25/solution-to-sicp-exercise-114/">Bhrgunatha</a>.<br /><br>Here is <a href="http://e.photos.cx/sicp.ex1.14-00b.png">the tree</a>.</p><br><p>As for the order, we can observe that at least in terms number of steps the growth follows that of our tree-recursive fibonacci function and is exponential. I think it's growing at <em>O(x<sup>n</sup>)</em> but it could be growing at <em>O(n<sup>x</sup>)</em>. Has anyone come to a definitive conclusion about this? Upon checking Ken Dyck's site again I see that Tim Eichner has an interesting solution. Can anyone confirm this?</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-15">1.15</a>:<br /><br>a. How many times is the procedure p applied when (sine 12.15) is evaluated?</p><br><pre lang="lisp"><br>(p (sine 4.05))<br>(p (p (sine 1.35)))<br>(p (p (p (sine 0.45))))<br>(p (p (p (p (sine 0.15)))))<br>(p (p (p (p (p (sine 0.05))))))<br>(p (p (p (p (p 0.05)))))</pre><br><p>P is applied 5 times.</p><br><p>b. What is the order of growth in space and number of steps (as a function of a) used by the process generated by the sine procedure when (sine a) is evaluated?</p><br><p>This one I did need help with. I realized quite clearly that the growth was related to the number of divisions by 3 our angle took to get below the threshold (0.01). I did not realize that the abstraction I was looking for to describe this growth was that of a logarithm. That being said, I checked a few other solutions and went over the wiki page for <a href="http://en.wikipedia.org/wiki/Logarithm">logarithms</a> once or twice. I really need to order <a href="http://www.amazon.com/Calculus-Michael-Spivak/dp/0914098896">Spivak's Calculus</a> now. Anyway, the process is <em>O(log(a))</em> in both space and time. Specifically it's <em>O(log<sub>3</sub>(n))</em>.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-16">1.16</a>:<br /><br>This was tricky until I modeled the state transformations holding to the rule suggested for (* a (b^n)). Once I did that it was pretty easy.</p><br><pre lang="lisp"><br>(define (expt b n)<br>  (define (expt-iter b n a)<br>  (cond ((= n 0) a)<br>	((even? n) (expt-iter (square b) (/ n 2) a))<br>	(else (expt-iter b (- n 1) (* a b)))))<br>  (expt b n 1))<br>;Value: expt-iter<br><br>(expt-iter 2 1000 1)<br>1071508607186267320948425049060001810561404811705533607443750388370351051124936122493198378815695858127594672917553146825187<br>1452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062<br>914571196477686542167660429831652624386837205668069376<br>;;That's a 300 digit number. This algorithm is O(log n). This computed in 16 steps.</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-17">1.17</a>:</p><br><pre lang="lisp"><br>(define (* a b)<br>  (define (double x)<br>    (+ x x))<br>  (define (halve x)<br>    (/ x 2))<br>  (cond ((= b 0) 0)<br>	((= a 0) 0)<br>	((= b 1) a)<br>	((even? b) (* (double a) (halve b)))<br>	(else (+ a (* a (- b 1))))))<br>;Value: *<br><br>(* 2 1000)<br>;Value: 2000<br>;;16 steps again. logarithmic in time. space too? I think it's just linear in space.</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-18">1.18</a>:</p><br><pre lang="lisp"><br>(define (* a b)<br>  (define (double x)<br>    (+ x x))<br>  (define (halve x)<br>    (/ x 2))<br>  (define (*-iter a b c)<br>    (cond ((= b 0) 0)<br>	  ((= a 0) 0)<br>	  ((= b 1) (+ a c))<br>	  ((even? b) (*-iter (double a) (halve b) c))<br>	  (else (*-iter a (- b 1) (+ c a)))))<br>  (*-iter a b 0))<br>;Value: *<br><br>(* 2 1000)<br>;Value: 2000<br>;;16 steps again. logarithmic and iterative, so it does it in O(1) space. boo-yah. today was a good day to code.</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-19">1.19</a>:<br /><br>This was just a really difficult problem to understand. I wasn't even sure what they were really asking. Once I realized I just needed to use algebra to try and expand and then factor out a few things I felt a lot more comfortable.</p><br><pre lang="lisp"><br>(define (fib n)<br>  (fib-iter 1 0 0 1 n))<br>;Value: fib<br><br>(define (fib-iter a b p q count)<br>  (cond ((= count 0 ) b)<br>	((even? count)<br>	 (fib-iter a<br>		   b<br>		   (+ (square p) (square q)) ;; compute p'<br>		   (+ (* 2 p q) (square q))  ;; compute q'<br>		   (/ count 2)))<br>	(else (fib-iter (+ (* b q) (* a q) (* a p))<br>			(+ (* b p) (* a q))<br>			p<br>			q<br>			(- count 1)))))<br>;Value: fib-iter</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-20">1.20</a>:<br /><br>This is one of those exercises that Abelman and Sussman are sort of bastards for including.</p><br><p>;;Normal order evaluation is fully expand to primitives and then reduce.<br /><br>;;Applicative-order is...well, what we've been doing all along.</p><br><p>How many remainder operations are performed in the normal order version of<br /><br>(gcd 206 40)?</p><br><p>How many in the applicative order version?<br /><br>4: (206 4), (40 6), (6 4), (4 2)</p><br><p>Applicative order first:<br /><br>(gcd 206 40)<br /><br>(gcd 40 (remainder 206 40))<br /><br>(gcd 40 6)<br /><br>(gcd 6 (remainder 40 6))<br /><br>(gcd 6 4)<br /><br>(gcd 4 (remainder 6 4))<br /><br>(gcd 4 2)<br /><br>(gcd 2 (remainder 4 2))<br /><br>(gcd 2 0)<br /><br>2</p><br><p>Normal order version:<br /><br>(gcd 206 40)<br /><br>;;we can count the number of times remainders occur in b, which is always evaluated.<br /><br>(gcd 40 (remainder 206 40)) ;;rc = 1<br /><br>if (= (remainder 206 40) 0) = false</p><br><p>(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))) ;;rc = 1+2<br /><br>if (= (remainder 40 6) 0) = false</p><br><p>(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ;;rc = 1+2+4<br /><br>if (= (remainder 6 4) 0) = false</p><br><p>(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ;;rc = 1+2+4+7<br /><br>if (= (remainder 4 2) 0) = true!<br /><br>now that if is true we evaluate a: (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) which has 4 remainders to the 14 that have been evaluated in prior predicates. tada! 18 evaluations in total for normal order. 4, if you didn't notice, for applicative order.</p><br><p>GCD is effectively a loop here and the only way for the loop to exit is for the if predicate to evaluate to true, after which the consequent is evaluated. The alternate is only substituted for in this case, never evaluated outright as it never becomes primitive.</p><br><p>In this way, the problem seems to me more of a study into the if conditional than evaluation models. Once you understand that the alternate never gets evaluated, you can simply figure out how many remainders get fed to it before it's true and then how many are in the consequent.</p><br><p>That's the best I could come up with for this one but <a href="http://eli.thegreenplace.net/2007/07/04/sicp-sections-124-125/">Eli Bendersky has a solution</a> you may find more clear or detailed.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-21">1.21</a>:</p><br><pre lang="lisp"><br>(smallest-divisor 199)<br>;Value: 199<br><br>(smallest-divisor 1999)<br>;Value: 1999<br><br>(smallest-divisor 19999)<br>;Value: 7</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-22">1.22</a>:<br /><br>The code for this exercise is not <em>particularly</em> difficult. It's not easy but it's fairly straightforward. Because this exercise was written over 10 years ago though it's pretty difficult to use on modern hardware. You're supposed to observe algorithmic efficiency because this code is supposed to stress your hardware. Unfortunately, in 2008 this code makes my hardware yawn for numbers on the scale they were asking for. So I started things off at 13 digits and scaled up from there. I also decided to rework the code so that it only outputs when it finds a prime.</p><br><pre lang="lisp"><br>(define (start-prime-test n start-time)<br>  (if (prime? n)<br>      (report-prime (- (runtime) start-time) n)))<br><br>(define (report-prime elapsed-time n)<br>  (newline)<br>  (display n)<br>  (display " *** ")<br>  (display elapsed-time))<br><br>(define (search-for-primes current end)<br>  (cond ((even? current) (search-for-primes (+ current 1) end))<br>	((> current end) (display " done! "))<br>	(else (timed-prime-test current)<br>	      (search-for-primes (+ current 2) end))))</pre><br><p>So, there's the code. Now for my results:<br /><br>(search-for-primes 100000000000 100000000060)</p><br><p>100000000003 *** 1.1600000000000037<br /><br>100000000019 *** 1.1899999999999977<br /><br>100000000057 *** 1.240000000000009 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 1000000000000 1000000000070)</p><br><p>1000000000039 *** 3.91<br /><br>1000000000061 *** 3.759999999999998<br /><br>1000000000063 *** 3.9400000000000013 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 10000000000000 10000000000100)</p><br><p>10000000000037 *** 12.280000000000001<br /><br>10000000000051 *** 12.510000000000005<br /><br>10000000000099 *** 12.200000000000003 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 100000000000000 100000000000098)</p><br><p>100000000000031 *** 38.190000000000026<br /><br>100000000000067 *** 38.16<br /><br>100000000000097 *** 37.95000000000002 done!<br /><br>;Unspecified return value</p><br><p>Checking all of these it appears we are very close to the projected (sqrt 10) increase per digit.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-23">1.23</a>:</p><br><pre lang="lisp"><br>(define (find-divisor n test-divisor)<br>  (cond ((> (square n) n) n)<br>	((= (modulo n test-divisor) 0) test-divisor)<br>	(else (find-divisor n (next test-divisor)))))<br>;Value: find-divisor<br><br>(define (next n)<br>  (cond ((even? n) (+ n 1))<br>        (else (+ n 2))))<br>;Value: next</pre><br><p>The results this time were:<br /><br>(search-for-primes 100000000000 100000000060)</p><br><p>100000000003 *** .7400000000000091<br /><br>100000000019 *** .7200000000000273<br /><br>100000000057 *** .7099999999999795 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 1000000000000 1000000000070)</p><br><p>1000000000039 *** 2.3600000000000136<br /><br>1000000000061 *** 2.2900000000000205<br /><br>1000000000063 *** 2.319999999999993 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 10000000000000 10000000000100)</p><br><p>10000000000037 *** 7.350000000000023<br /><br>10000000000051 *** 7.340000000000032<br /><br>10000000000099 *** 7.189999999999998 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 100000000000000 100000000000098)</p><br><p>100000000000031 *** 23.110000000000014<br /><br>100000000000067 *** 22.879999999999995<br /><br>100000000000097 *** 22.920000000000016 done!<br /><br>;Unspecified return value</p><br><p>This time we also are pretty close to half the previous times but it's slightly over half.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-24">1.24</a>:</p><br><pre lang="lisp"><br>(define (start-prime-test n start-time)<br>  (if (fast-prime? n 500)<br>      (report-prime (- (runtime) start-time) n)))<br>;Value: start-prime-test</pre><br><p>And these results were:<br /><br>(search-for-primes 100000000000 100000000060)</p><br><p>100000000003 *** 9.999999999990905e-3<br /><br>100000000019 *** 0.<br /><br>100000000057 *** 9.999999999990905e-3 done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 1000000000000 1000000000070)</p><br><p>1000000000039 *** 0.<br /><br>1000000000061 *** 9.999999999990905e-3<br /><br>1000000000063 *** 0. done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 10000000000000 10000000000100)</p><br><p>10000000000037 *** 0.<br /><br>10000000000051 *** 0.<br /><br>10000000000099 *** 0. done!<br /><br>;Unspecified return value</p><br><p>(search-for-primes 100000000000000 100000000000098)</p><br><p>100000000000031 *** 9.999999999990905e-3<br /><br>100000000000067 *** 0.<br /><br>100000000000097 *** 0. done!<br /><br>;Unspecified return value</p><br><p>We can see that this is definitely in <em>O(log(n))</em>. The times have gone below the precision of my instruments in most cases.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-25">1.25</a>:<br /><br>I honestly had to look to <a href="http://eli.thegreenplace.net/2007/07/04/sicp-sections-124-125/">Eli</a> and <a href="http://http://www.kendyck.com/archives/2005/06/19/solution-to-sicp-exercise-125/">Ken</a> for help on this one. I was hand evaluating the original code before trying Alyssa's and having some trouble. I had noticed that the fast-expt procedure had two arguments where expmod had three so I figured part of the computation was being moved around. I even realized that Alyssa's way went ahead and computed the base to the exponent and then tested the remainder against it once. That just seemed like it should've been better to me. I didn't have the sense to just add runtime in as an argument and see how much time they were taking. At any rate, the original expmod does lots of little remainder tests but because of <a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">Bignum arithmetic</a> that ends up being faster than a single test on a huge number.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-26">1.26</a>:<br /><br>(expmod base (/ exp 2) m) has to be evaluated an extra time each time the (even? exp) condition evaluates to true. This moves the algorithm from log n to n because, as I somewhat foolishly missed, it shifts the recursion from a linear recursion to a tree recursion. See the <a href="http://sicp.org.ua/sicp/Exercise1-26">SICP Wiki's solution</a> for more detail, it seems to be the best resource for rigorous complexity analysis.</p><br><p><a href="http://sicp.org.ua/sicp/Exercise1-27">1.27</a>:</p><br><pre lang="lisp"><br>(define (expmod base exp m)<br>  (cond ((= exp 0) 1)<br>	((even? exp)<br>	 (remainder (square (expmod base (/ exp 2) m)) m))<br>	(else<br>	 (remainder (* base (expmod base (- exp 1) m)) m))))<br>;Value: expmod<br><br>(define (carmichael-test n)<br>  (define (try-it a)<br>    (= (expmod a n n) a))<br>  (define (carmichael-iter times)<br>    (cond ((= times 0) true)<br>	  ((try-it times) (carmichael-iter (- times 1)))<br>	  (else false)))<br>  (carmichael-iter (- n 1)))<br>;Value: carmichael-test</pre><br><p><a href="http://sicp.org.ua/sicp/Exercise1-28">1.28</a>:</p><br><pre lang="lisp"><br>(define (expmod base exp m)<br>  (define (miller-rabin x)<br>    (and (not (= x 1)) (not (= x m)) (= (square x) (modulo 1 m))))<br>  (cond ((= exp 0) 1)<br>	((even? exp)<br>	 (if (miller-rabin (square (expmod base (/ exp 2) m)))<br>	     0<br>	     (remainder (square (expmod base (/ exp 2) m))<br>			m)))<br>	(else<br>	 (remainder (* base (expmod base (- exp 1) m))<br>		    m))))<br>;Value: expmod<br><br>(define (miller-rabin-search n)<br>  (define (try-it a)<br>    (= (expmod a (- n 1) n) 1))<br>  (try-it (+ 1 (random (- n 1)))))<br>;Value: miller-rabin-search<br><br>(define (miller-rabin-test n)<br>  (define (mr-iter count)<br>    (cond ((= count 1) #t)<br>             ((miller-rabin-search n) (mr-iter (- count 1)))<br>             (else #f)))<br>  (mr-iter (floor (/ n 2))))<br>;Value: miller-rabin-test<br><br>;;I got everything written right on this one but I had to check Ken's page again to notice that my try-it definition was<br>;;testing the expmod result against a, not 1. Once I fixed that I was right as rain.</pre><br><p>As a final note, I should point out that my solution here differs a bit from the norm. One, I'm pretty serious about not using primitives that haven't been introduced yet. Even <a href="http://www.kendyck.com/archives/2007/05/30/solution-to-sicp-exercise-128/">Ken Dyck's solution</a> uses let (though the <a href="http://sicp.org.ua/sicp/Exercise1-28">SICP wiki avoids it</a>). After all, this is my first serious work in programming ever. The closest thing besides this was my read through the <a href="http://www.redlinernotes.com/blog/?p=443">first chapter of K&R in summer of 2006</a>. Anyway, just keep in mind I'm taking this as my formal education.</p>
