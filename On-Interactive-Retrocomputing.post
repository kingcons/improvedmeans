;;;;;
title: On Interactive Retrocomputing
tags: LISP, Programming
date: 2012-06-18 04:27:59
format: html
;;;;;
Lately, I've been working on an emulator for the <a href="http://en.wikipedia.org/wiki/MOS_Technology_6502">MOS 6502</a> processor in Common Lisp that I've been boring enough to name <a href="http://github.com/redline6561/cl-6502">cl-6502</a>. The emulator is basically finished as is the disassembler. There are also pretty solid docs. An assembler should be added soon and hopefully a helper utility or two and unit tests. But why do this? Well, for a couple of reasons.<br><br>1) I never did enough Systems Programming. I never did any assembly in college and wrote an absolute paucity of C (granted, that's my fault). I never learned enough about the inner working of Operating Systems or how to exploit memory hierarchies. I want to know more about how the machine works at a low level. Writing an emulator in a high-level language isn't a great way to do that but I wanted to anyway. Writing some assembly programs to run on this emulator might help though and I hope to do some of that later.<br><br>2) I was curious how concise, extensible, and performant an emulator could be written with Common Lisp. Most emulators are written in C/C++ for performance reasons. There are a few in Java (for portability?) or Javascript for what we now call portability but even these are not terribly high-level from a design perspective. I don't have all the answers to this question yet but I'm excited by some of the work I've done so far. In particular, writing macros for <a href="https://github.com/redline6561/cl-6502/blob/master/src/cpu.lisp#L184">Addressing Modes</a> and <a href="https://github.com/redline6561/cl-6502/blob/master/src/cpu.lisp#L255">Opcodes</a> has been quite helpful and I expect CLOS's :before, :after, and :around methods to go a long way where extensibility is concerned. I'm hoping the EQL-specialized methods, SBCL, and perhaps some shrewd profiling can lead to good performance. Also, <a href="https://github.com/redline6561/cl-6502/blob/master/src/disassemble.lisp">45 lines of code</a>Â for a 6502 disassembler doesn't seem bad to me. :P<br><br>3) <a href="http://www.youtube.com/watch?v=tjcvR5McmSg">ICU64/Frodo Redpill</a>. I'm not wild about static types and I tend to write tests after the fact because I view programs as clay until they're ready to be fired in the kiln. Roly Perera's work on <a href="http://dynamicaspects.org/blog/2012/06/10/self-explaining-computation/">self-explaning computation</a> interests me a lot as does Chris Granger's work on <a href="http://www.chris-granger.com/2012/05/21/the-future-is-specific/">Light Table</a>. Rapid feedback loops are important. Maintaining flow is important. As far as I'm concerned, all emulators should strive towards the sort of "peek/poke the machine" experience that ICW/Frodo Redpill offers. Games are a very easy way to get people to engage with computers. Everybody likes games. And lots of folks at some point in wondering about programming, ponder how much is involved in changing something about a game they like. With a system like ICU/Frodo Redpill they could literally /see/ the answer. Add an integrated editor and you're in pretty interesting territory. Feel like changing something about the "hardware"? Feel like having breakpoints and step debuggers pop up on arbitrary memory accesses or instruction executions? You got it. But ICU64/Frodo Redpill has this all locked down on desktops. Why not do as much as possible with HTML5, &lt;canvas&gt;, and Clojurescript? I'm not going to be the guy to come up with the next <a href="http://en.wikipedia.org/wiki/The_Mother_of_All_Demos">Mother of all Demos</a> ... but I hope to make something cool. And if I'm really lucky, I'll have something interesting to play with online by <a href="http://thestrangeloop.com/">Strange Loop</a> on September 23rd. I've already got a 6502 emulator. What's next?
