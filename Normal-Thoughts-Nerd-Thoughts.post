;;;;;
title: Normal Thoughts, Nerd Thoughts
tags: Hardware, Music, Operating Systems, Personal, Programming Languages
date: 2009-02-01 00:18:46
format: html
;;;;;
I'm going to try to keep this short. Top 5 things that have been stuck in my head the last 2 days.<br><br>1: Actually, 1 hasn't been stuck in my head it's a few interesting news bits from this morning. One being <a href="http://lynch.foreignpolicy.com/posts/2009/01/27/obama_on_al_arabiya">an interesting interview and look at Middle East policy with Obama</a>, the other being <a href="http://mediamatters.org/countyfair/200901280009?show=1">Jessica Alba calling out Bill O'Reilly on WWII neutrality</a>. I normally wouldn't post the latter sort of junk but I found it pretty funny for one reason or another.<br><br>2: Amon Tobin is awesome. Literally, awesome. My favorite two albums of his are Supermodified and Permutation but I can't choose between those two. Seriously though, just listen to <a href="http://www.youtube.com/watch?v=yp_WfPRnHME">Nightlife</a> off of <a href="http://en.wikipedia.org/wiki/Permutation_(album)">Permutation</a> or <a href="http://www.youtube.com/watch?v=TCuUcTi_iSg">Slowly</a> off of <a href="http://en.wikipedia.org/wiki/Supermodified_(album)">Supermodified</a>. Listen to those for me. Please. Tell me they're not masterfully composed or beautiful. It's all sample-based. He's staggering.<br><br>3: I'm going to be moving by the end of may. I need to save up for a down payment on an apartment (with Teresa) somewhere nearby and public transit accessible. I may also change internet service providers. If I do that, does it make sense to buy hosting from <a href="https://www.linode.com/faq.cfm">someone</a> (I'd definitely choose a <a href="https://www.linode.com/avail.cfm">Linode 360 in Atlanta at $20/month</a>)? I'd still keep a server at home for, uh..."file transfer operations", media serving and SSH access or some such. I just don't want to have to run redlinernotes.com off of it for bandwidth and downtime reasons.<br><br>**Computer Nerd warning: I think what follows may be the most concise explanation of what really interests <em>me</em> in Computer Science that I've written, namely item 5. Item 4 is prerequisites, sort of. If you want to understand some of the reasons I'm into computing and the questions that interest me you could do worse than read what follows. Note that I think Computer Science is <em>generally</em> one of the most interesting fields that exists because it lets you study anything: Games, AI (Psychology/Philosophy/Ontology/Nature of intelligence), Theory of Computation (Mathematical Foundations of Logic), User Interface Design/HCI (Psychology/Aesthetics/Usability), Programming Languages (Linguistics). etc...but what follows are my personal reasons, not general ones.**<br><br>4: I posted <a href="http://www.reddit.com/r/programming/comments/7t5vi/the_highlevel_cpu_challenge/">this reddit thread</a> yesterday but the topics debated are so interesting to me I'm going to post it again. Consequently, I've spent this morning peeking at <a href="http://www.memetech.com/">things like this</a>, and <a href="http://lambda-the-ultimate.org/node/3089">a</a> <a href="http://www.bitc-lang.org/docs/papers/PLOS2006-shap.html">lot</a> <a href="http://www.bitc-lang.org/docs/papers/APLAS2008.html">of</a> <a href="http://www.bitc-lang.org/docs/osverify-2004/osverify-2004.html">the</a> <a href="http://www.bitc-lang.org/docs/papers/PLOS2006-shap.html#brewer2005thirty">work</a> <a href="http://srl.cs.jhu.edu/~shap/">Jonathan Shapiro</a> has been doing over the last few years, particularly <a href="http://en.wikipedia.org/wiki/BitC">BitC</a> and <a href="http://en.wikipedia.org/wiki/Coyotos">Coyotos</a>. I came into programming last year excited about my understanding that to support <a href="http://gigaom.com/2008/11/08/programming-a-parallel-future/">the trend</a> <a href="http://blog.monstuff.com/archives/000333.html">towards</a> <a href="http://en.wikipedia.org/wiki/Parallel_computing">parallelism</a> we had to rework something significant on at least one of the following levels {<a href="http://en.wikipedia.org/wiki/Computer_architecture">Computer Architecture</a>, <a href="http://en.wikipedia.org/wiki/Operating_system">Operating Systems</a>, <a href="http://en.wikipedia.org/wiki/Programming_language">Programming Languages</a>}.<br><br>I also understood that the field had a lot of lovely innovations which (debatably) never conquered the mainstream such as <a href="http://en.wikipedia.org/wiki/Lisp_programming_language">Lisp</a>, <a href="http://en.wikipedia.org/wiki/Unix">Unix</a> on one side, <a href="http://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan 9</a> on the other, <a href="http://en.wikipedia.org/wiki/RISC#RISC_and_x86">RISC architectures</a>, etc. One always has to struggle with <a href="http://en.wikipedia.org/wiki/Worse_is_better">Worse is Better</a>. Note that I did say debatably, Lisp/Scheme increasingly influence recent languages, Unix is slowly working towards the consumer market through <a href="http://en.wikipedia.org/wiki/Mac_OS_X">OS X</a> and <a href="http://en.wikipedia.org/wiki/Linux">Linux</a> and has always been strong in Industry, Plan 9...well...[pdf warning]<a href="http://www.superfrink.net/athenaeum/utah2000.pdf">Rob Pike has some interesting words</a>[\pdf], and Intel's x86 chips apparently hardware translate the <a href="http://en.wikipedia.org/wiki/Complex_instruction_set_computer">CISC</a> <a href="http://en.wikipedia.org/wiki/Instruction_set">ISA</a> <a href="http://www.reddit.com/r/programming/comments/7ecrl/ask_proggit_why_do_we_use_x86_processors/c06fx5r">down to some sort of RISC-like micro-ops</a>.<br><br>The point is the solutions which were elegant or "technologically superior" did not tend to be the ones favored by the market for various reasons. Note that I am not saying we all should be using Lisp Machines. These technologies were beaten in the market for good reasons but that doesn't mean they were a direction we shouldn't pursue. Consequently, I am beginning to understand that because the foundations of this industry which has taken over the world since 1970 are in many ways <a href="http://74.125.47.132/search?q=cache:Dnl1Us2w9RwJ:www.cs.berkeley.edu/~zf/papers/ivy-hotos05.pdf+Thirty+Years+is+Long+Enough:+Getting+Beyond+C&amp;hl=en&amp;ct=clnk&amp;cd=1&amp;gl=us&amp;client=firefox-a">fundamentally unsound</a> that we should harbor a desire to eventually rework those foundations. Namely by the insertion of abstractions to aid the modern programmer in issues of parallelism and secure and reliable code.<br><br>5: I guess the question that really gets me is, "<em><strong>Where should all this abstraction be?</strong></em>". That is, what are the right layers in which to have the abstractions we settle upon? I think a number of things suggest that the Computer Architecture and Operating System layers are not the correct ones and that the abstractions should wind up in our Programming Languages. Backwards compatibility and the price-performance competition with existing industry being the principle obstacles to Architecture and Operating Systems. Of course, once you've figured out where the abstraction should be you have to move on to "<em><strong>How do we create these abstractions and put them in their place?</strong></em>" or the question of implementation which is for all intents and purposes much harder. This has taken way too long to write and I'm pretty spent at the moment. Hopefully, I'll get a chance to flesh out these ideas later.<br><br>**/end nerdery**<br><br>PS: It's begun. Mike Miller was right. I'm doomed to be a Computer Historian...
