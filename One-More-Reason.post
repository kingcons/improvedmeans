;;;;;
title: One More Reason
tags: Linux
date: 2008-02-15 18:44:31
format: html
;;;;;
I knew this day would come sooner or later. I finally ran up against a task that was perfect to use <a href="http://en.wikipedia.org/wiki/Pipeline_(Unix)">Unix Pipes</a> for. I needed to rename 2335 MP3s and I did it in 1 minute and 40.686 seconds.<br><br>Here's the backstory:<br>I recently got a new MP3 player because my old one died. When I got my last MP3 player I had selected the 2000 songs I actually liked and regularly listened to out of my 17000 or 18000 and copied them to the MP3 player and my PS3. Those songs were sort of a pain to get off my PS3 onto the new player so I figured I might as well keep a separate copy of them somewhere on my desktop. Eventually I'm planning on moving them to my server as well at which point <a href="http://redlinernotes.com/jukebox">Redline Radio</a> will get up and running again!<br><br>Anyway, I copied all the files off of my new MP3 player to my desktop to create said separate copy and found that the filename on each song had been changed to SONG_NAME.b-mtp-XXXX where the X's were the song numbers up to 2335. I'll be damned if I was going to rename all those by hand. So, I thought I'd use Unix Pipes which allow you to take the output from one command and feed it into another command. And just for fun, I timed it.<br><br>To time a command you just put the word time in front of it. So to time the change directory command you'd type, "time cd DIRECTORY". To rename all those files I would use the rename command, but it would only rename one file at a time or at best one directory. I had a few hundred directories. So, I needed a command that would find each file by searching through the directories and find is the perfect command for the job. I can call find and tell it to search for files with that weird extension and then each time it does, run rename on the file with a <a href="http://en.wikipedia.org/wiki/Regular_expression#POSIX_Basic_Regular_Expressions">regular expression</a> to change that extension to mp3. And here's how that looks:<br><pre><br>time find ./ -type f -exec rename 's/b-mtp-[0123456789]*/mp3/' {} ;<br></pre><br>That's it. It says time the find command searching from this directory down for files (ignoring directories, etc) and when you find one rename it based on this regular expression. Done. 2000 files renamed in 2 minutes. And people wonder why I use Linux. Yes, Apple Automator does do this. But do you know why the robot icon for Automator is holding a pipe? That's right. It's an homage to Unix Pipes. You could of course do this in Apple's Terminal. That would be pretty cool. You hear me Dobbs?<br><br>Anyway, I've been thinking a bit about Alan Perlis' Programming Epigram: "A language that doesn't affect the way you think about programming, is not worth knowing." And I think there's an analogue for Operating Systems as well in all likelihood. Text editors, too (here comes the <a href="http://en.wikipedia.org/wiki/Editor_war">Vi vs. Emacs</a> crowd). So, I may be using a <a href="http://en.wikipedia.org/wiki/Blub_%28programming%29">blub</a> operating system but I haven't soaked up all I can learn from it yet. I just need to remember to try other things too.<br><br>Just for fun, here's one more. This one outputs the 50 largest directories on my hard drive and their sizes to a text file on my desktop. du is Disk Usage, the -S option tells it to not to include subdirectories (so I only get leaves and not branches of the filesystem tree in my results). | passes output from one command as input to the next so | sort -nr passes the list of the directories and their sizes to sort which thanks to the nr switch sorts them in Reverse Numerical order. Greatest first, right? Then | head -n50 takes that output and cuts off everything after the first 50 lines. Finally, > dumps the final output into a text file at the location given. Ta da.<br><pre><br>du -S / | sort -nr | head -n50 > /home/redline/Desktop/50large.txt</pre>
