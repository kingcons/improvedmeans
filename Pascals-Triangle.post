;;;;;
title: Pascalâ€™s Triangle
tags: LISP, Programming, Self-Learning, SICP
date: 2008-02-07 03:25:28
format: html
;;;;;
<p>A little over two weeks ago I came up against <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#call_footnote_Temp_54">Exercise 1.12</a> in <a href="http://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">the venerable Structure and Interpretation of Computer Programs</a>.</p><br><p>The exercise wants you to write a recursive program to compute elements of <a href="http://en.wikipedia.org/wiki/Pascal's_triangle">Pascal's Triangle</a>.</p><br><p>This exercise has pretty much infuriated me and it's all my own fault. Upon first hearing the problem statement I got it in my head that the function should look something like "(define (pas n)...)". I always think of number series  being described in terms of a single argument (i.e. the 12th element) so it seemed natural to me that the pascal's triangle function should be computed in this way even though it is not, in some sense, a traditional series.</p><br><p>After a while, I cracked and read the precursor text (but not the code) to <a href="http://eli.thegreenplace.net/2007/06/28/sicp-section-122/">Eli Bendersky's solution</a> and noticing that he defined the function with two arguments (for columns and rows) arrived fairly quickly with that insight at what seems to be the <a href="http://www.kendyck.com/archives/2005/03/22/solution-to-sicp-exercise-112/">more </a>or <a href="http://blog.petersheats.com/2007/09/11/exercise-112/">less</a> standard solution. I have had this much completed for a week but gotten stalled trying to figure out the problem of a pascal function that takes one argument.</p><br><p>As of today I've solved the problem though and hoped to share my results here. First, the throwaway code that ended up being good for nothing!</p><br><pre><br>(define (is-one? element)<br>  (define (is-one-iter ones count flag)<br>    (cond ((< element 5) #t)<br>	  ((= ones element) #t)<br>	  ((> ones element) #f)<br>	  ((= flag 1) (is-one-iter (+ ones 1) count (- flag 1)))<br>	  (else (is-one-iter (+ ones count) (+ count 1) (+ flag 1)))))<br>  (is-one-iter 4 2 0))<br>;Value: is-one?</pre><br><p>That code tests to see whether a given element equals one and it does take a single argument which is nice. I couldn't figure out a way to use it to compute the actual elements though.</p><br><p>After a little bit of experimenting I stumbled on <a href="http://www.research.att.com/~njas/sequences/A080956">this number sequence</a> (OEIS #A080956) which when put in the following procedure would allow me to compute n from a given column and row.</p><br><p>EDIT: Corrected dyslexic mistake in my code (I'd replaced all instances of col with row and vice versa). See comments.</p><br><pre><br>(define (n-from-rowcol row col)<br>  (define (f x)<br>    (- (/ (* (+ x 1) (- 2 x)) 2)))<br>  (+ row col (f (- row 1))))<br>;Value: n-from-rowcol</pre><br><p>Now all I had to do was find a way to reverse the function to give me the inputs if I gave it the output. I actually stumbled upon <a href="http://www.research.att.com/~njas/sequences/A000124">another number sequence </a>(OEIS #A000124, also known as the <a href="http://en.wikipedia.org/wiki/Lazy_caterer's_sequence">Lazy Caterer's Sequence</a>) which when put into the following procedure returns the correct column and row for a given element. At last, working code:</p><br><pre><br>(define (pascal n)<br>  (define (pas col row)<br>    (cond ((= col 1) 1)<br>	  ((= row 1) 1)<br>	  ((= col row) 1)<br>	  (else (+ (pas (- col 1) row)<br>		   (pas (- col 1) (- row 1))))))<br>  (define (colrow-from-n)<br>    (define (col-iter count)<br>      (define (f x)<br>	(- (/ (+ (square x) x 2) 2) x))<br>      (cond ((> (f count) n) (pas (- count 1) (- n (- (f (- count 1)) 1))))<br>	    ((= (f count) n) (pas (f count) 1))<br>	    (else (col-iter (+ count 1)))))<br>    (col-iter 1))<br>(colrow-from-n))<br>;Value: pascal</pre><br><p>Any insights into cleaner code, better algorithms, or comparisons between the two number series are welcomed.</p>
