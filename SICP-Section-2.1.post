;;;;;
title: SICP Section 2.1
tags: LISP, Self-Learning, SICP
date: 2008-08-07 20:54:02
format: html
;;;;;
It's taken far too long to post this up and the last four problems remain unfinished. That said, I want to get more of the solutions I've worked written up and I shouldn't have waited this long in the first place. With any luck Section 2.2 will follow within a week. I'm around half done with it and you can see some solutions <a href="http://www.redlinernotes.com/code">here</a>.<br><br><!--more--><br><br>Resources:<br>Read: <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-13.html#%_chap_2">Chapter 2</a> through <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html">Section 2.1</a><br>Watch: <a href="http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/">Lecture</a> <a href="http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/videos/Lecture-2b.avi">2-b</a><br>Checked against: <a href="http://eli.thegreenplace.net/category/programming/lisp/sicp/">Eli Bendersky's Blog</a>, <a href="http://sicp.org.ua/sicp/Section2-1">SICP Wiki</a>, <a href="http://www.kendyck.com/solutions-to-sicp/">Ken Dyck's Solutions</a>, <a href="http://theloserblog-home.blogspot.com/search/label/SICP">Theloserblog</a>, <a href="http://wfasim.dyndns.org/wordpress/?page_id=136">Wfasim's Solutions</a> and the Scheme Wiki and Personal Wiki solutions listed <a href="http://doingthistolearn.net/links/SICP.html">here</a>.<br><br>SICP Notes and Exercises:<br><br>Notes<br><br>Quotes<br><br>Exercises<br><a href="http://sicp.org.ua/sicp/Exercise2-1">2.1</a>:<br><pre lang="scheme"><br>(define (make-rat n d)<br>  (let ((g (gcd n d)))<br>    (if (positive? (/ n d))<br>	(cons (abs (/ n g)) (abs (/ d g)))<br>	(cons (- (/ n g)) (abs (/ d g))))))<br>;Value: make-rat</pre><br><br><a href="http://sicp.org.ua/sicp/Exercise2-2">2.2</a>:<br><pre lang="scheme"><br>(define (make-point x y)<br>  (cons x y))<br>;Value: make-point<br><br>(define (x-point point)<br>  (car point))<br>;Value: x-point<br><br>(define (y-point point)<br>  (cdr point))<br>;Value: y-point<br><br>(define (start-segment segment)<br>  (car segment))<br>;Value: start-segment<br><br>(define (end-segment segment)<br>  (cdr segment))<br>;Value: end-segment<br><br>(define (make-segment p1 p2)<br>  (cons p1 p2))<br>;Value: make-segment<br><br>(define (print-point p)<br>  (newline)<br>  (display "(")<br>  (display (x-point p))<br>  (display ",")<br>  (display (y-point p))<br>  (display ")"))<br>;Value: print-point<br><br>(define (midpoint-segment s)<br>  (make-point (average (x-point (start-segment s))<br>		       (x-point (end-segment s)))<br>	      (average (y-point (start-segment s))<br>		       (y-point (end-segment s)))))<br>;Value: midpoint-segment</pre><br><br>This is really interesting to me. I feel like midpoint-segment should be expressible in 2 or 4 lines of code but I can't think of a way to elegantly do that with lets or function composition. The problem is each time you're composing different sets of functions. Without defining multiple lets or compositions it doesn't compress and if you do you lose your LOC gains anyway. I've decided this definition is sufficiently succinct.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-3">2.3</a>:<br><pre lang="scheme"><br>;;representation 1 - procedure based, working by magic:<br>(define (rect-area r)<br>  (* (length r) (width r)))<br>;Value: rect-area<br><br>(define (rect-perimeter r)<br>  (* 2 (+ (length r) (width r))))<br>;Value: rect-perimeter<br><br>(define (make-rect top-left bottom-right)<br>  (cons top-left bottom-right))<br>;Value: make-rect<br><br>(define (length r)<br>  (- (y-point (car r)) (y-point (cdr r))))<br>;Value: length<br><br>(define (width r)<br>  (- (x-point (cdr r)) (x-point (car r))))<br>;Value: width<br><br>;;representation 2 - not procedure based, working by reality:<br>(define (make-rect top bottom)<br>  (cons top bottom))<br>;Value: make-rect<br><br>(define (rect-top r)<br>  (car r))<br>;Value: rect-top<br><br>(define (rect-bottom r)<br>  (cdr r))<br>;Value: rect-bottom<br><br>(define (rect-left r)<br>  (make-segment (start-segment top)<br>		(start-segment bottom)))<br>;Value: rect-left<br><br>(define (rect-right r)<br>  (make-segment (end-segment top)<br>		(end-segment bottom)))<br>;Value: rect-right<br><br>(define (length r)<br>  (- (y-point (start-segment (rect-top r)))<br>     (y-point (start-segment (rect-bottom r)))))<br>;Value: length<br><br>(define (width r)<br>  (- (x-point (end-segment (rect-top r)))<br>     (x-point (start-segment (rect-top r)))))<br>;Value: width</pre><br><br>What working by magic really seems to do is make the cruft that's unnecessary to your implementation obvious.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-4">2.4</a>:<br><pre lang="scheme"><br>(define (cons x y)<br>  (lambda (m) (m x y)))<br>;Value: cons<br><br>(define (car z)<br>  (z (lambda (p q) p)))<br>;Value: car<br><br>(define (cdr z)<br>  (z (lambda (p q) q)))<br>;Value: cdr</pre><br><br>Wow. Just wow.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-5">2.5</a>:<br><pre lang="scheme"><br>(define (cons a b)<br>  (* (expt 2 a) (expt 3 b)))<br>;Value: cons<br><br>(define (what-exponent x y)<br>  (define (exp-iter count)<br>    (if (= (modulo y (expt x count)) 0)<br>	(exp-iter (+ count 1))<br>	(- count 1)))<br>  (exp-iter 1))<br>;Value: what-exponent<br><br>(define (car x)<br>  (what-exponent 2 x))<br>;Value: car<br><br>(define (cdr x)<br>  (what-exponent 3 x))<br>;Value: cdr</pre><br><br>This isn't quite as evil as the problem description makes it sound.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-6">2.6</a>:<br>Whew boy. Here goes...<br><br><pre lang="scheme"><br>(define zero (lambda (f) (lambda (x) x)))<br>;Value: zero<br><br>(define (add-1 n)<br>  (lambda (f) (lambda (x) (f ((n f) x)))))<br>;Value: add-1<br><br>(add-1 zero)<br>(lambda (f) (lambda (x) (f ((zero f) x))))<br>(lambda (f) (lambda (x) (f x))) ;; this was the difficult step for me. why? i couldn't understand how ((zero f) x) got worked down to x. I knew that the identity function was what eventually got returned but I figured it received f as it's argument. The trick was recalling that f gets passed into a function which does NOTHING WITH F and returns the identity function anyway. (zero f) reduces to the identity function because of the first lambda in zero that just throws it's argument away. Hence, you have (identity x) which is just x and leaves this result as one. somewhat sadly, formatting my code so that the substitution wasn't all on one line also could've made the difference and saved me a week or so.<br><br>(define one (lambda (f) (lambda (x) (f x))))<br>;Value: one<br><br>(add-1 one)<br>(lambda (f) (lambda (x) (f ((one f) x))));; again the f arg is thrown away and x is put into the second lambda to give...<br>(lambda (f) (lambda (x) (f (f x))))<br><br>(define two (lambda (f) (lambda (x) (f (f x)))))<br>;Value: two<br><br>;;clearly we're adding an application of f each time we add one. for example...<br>((two square) 5)<br>;Value: 625<br>;; which is the square of the square of 5 (* 25 25)<br><br>;;now i'm supposed to define an addition function which should perform like so:<br>(add one two)<br>(add (lambda (f) (lambda (x) (f x)))<br>     (lambda (f) (lambda (x) (f (f x)))))<br>...<br>(lambda (f) (lambda (x) (f (f (f x)))))<br>;;and then allow us to do this<br>(((add one two) square) 5)<br>(square (square (square 5)))<br>;Value: 390625<br><br>;;maybe the hard part of this problem is holding multiple levels of evaluation in your head at the same time. anyway...<br>;;it seems like what we really want to do is feed the f chains into each other somehow...p<br><br>(define (add a b)<br>  (lambda (f) (lambda (x) ((a f) (b f)) x)))<br>;Value: add<br><br>;;this is tempting but wrong. i realized you had to pass the f in to make sure you got the correct repeated calls but missed that if you passed (b f) into the resulting function you were passing a procedure instead of a value.<br><br>(define (add a b)<br>  (lambda (f) (lambda (x) ((a f) ((b f) x)))))<br>;Value: add<br><br>(add one two)<br>(lambda (f) (lambda (x) ((one f) ((two f) x))))<br>(lambda (f) (lambda (x) ((one f)<br>			 ((lambda (x) (f (f x))) x))))<br>(lambda (f) (lambda (x)<br>	      (lambda (x) ((f x)<br>			   (lambda (x) (f (f x)) x)))<br>(lambda (f) (lambda (x) (f (f (f x)))))<br><br>;;you want to hear what's really gross? i found that this worked for odd numbers but not even numbers and tried unsuccessfully to figure out what was wrong for an hour before re-evaluating my definitions for one and two and seeing it "just work".<br><br>(((add one two) square) 5)<br><br>(define (test churchnum)<br>  (define (inc x)<br>    (+ x 1))<br>  ((churchnum inc) 0))<br>;Value: test<br><br>(test (add one two))<br>;Value: 3<br><br>;;it's sort of insulting that after writing all that code you realize<br>you just implemented a fancy lambda version of repeated for<br>functions/church numerals.<br><br>;;proving above point:<br>(define (compose f g)<br>  (lambda (x) (f (g x))))<br>;Value: compose<br><br>(define (repeated f n)<br>  (if (= n 1)<br>      f<br>      (compose f (repeated f (- n 1)))))<br>;Value: repeated<br><br>(define (add a b)<br>  (lambda (f) (repeated f (+ a b))))<br>;Value: add<br><br>;;of course, this pretends that church numerals are integers but...you get the idea.<br></pre><br><br>This may have been the hardest problem I encountered thus far and I definitely had to peek at the way other people started solving the problem to get my own ideas flowing in the right direction.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-7">2.7</a>:<br><pre lang="scheme"><br>(define (lower-bound i)<br>  (car i))<br>;Value: lower-bound<br><br>(define (upper-bound i)<br>  (cdr i))<br>;Value: upper-bound</pre><br><br><a href="http://sicp.org.ua/sicp/Exercise2-8">2.8</a>:<br><pre lang="scheme"><br>(define (sub-interval x y)<br>  (let ((p1 (- (lower-bound x) (lower-bound y)))<br>	(p2 (- (lower-bound x) (upper-bound y)))<br>	(p3 (- (upper-bound x) (lower-bound y)))<br>	(p4 (- (upper-bound x) (upper-bound y))))<br>    (make-interval (min p1 p2 p3 p4)<br>		   (max p1 p2 p3 p4))))<br>;Value: sub-interval</pre><br><br>Similiar to the addition function the maximum value the difference could be is that of the furthest upper and lower bound and the minimum difference is that of the closest upper and lower bound. This seems to be the best way to test for that.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-9">2.9</a>:<br><pre lang="scheme"><br>(define (width-interval x)<br>  (/ (- (upper-bound x) (lower-bound x))<br>     2))<br>;Value: width-interval<br><br>(width-interval (mul-interval inter1 inter2))<br>;Value: 24<br><br>(width-interval (div-interval inter1 inter2))<br>;Value: .5333333333333334<br><br>(width-interval (add-interval inter1 inter2))<br>;Value: 4<br><br>(width-interval (sub-interval inter1 inter2))<br>;Value: 4</pre><br><br>Observe that the width of the interval which is the difference between inter1 and inter 2 is identical to the width of the interval which is the sum of inter1 and inter2.<br>This fact indicates that the width of summed or subtracted intervals is a function of the width of their source intervals. You can clearly see that the width of the intervals produced by multiplying or dividing inter1 and inter2 do not share this trait. Thus, the width of multiplied or divided intervals is not a function of their source intervals alone.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-10">2.10</a>:<br><pre lang="scheme"><br>(define (div-interval x y)<br>  (if (<= (or (upper-bound y) (lower-bound y)) 0)<br>      (error "Cannot divide by an interval that spans zero." y)<br>      (mul-interval x<br>		    (make-interval (/ 1.0 (upper-bound y))<br>				   (/ 1.0 (lower-bound y))))))<br>;Value: div-interval</pre><br><br>This fixes the issue of dividing by zero in the software by simply not allowing intervals to drop below zero. Whether intervals that "span" zero should be allowed is up for debate.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-11">2.11</a>:<br><pre lang="scheme"><br>(define (mul-interval x y) ;;even with lets this is ugly. i object!<br>  (let ((a (lower-bound x))<br>	(b (upper-bound x))<br>	(c (lower-bound y))<br>	(d (upper-bonud y)))<br>    (cond ((and (> a 0) (> b 0) (> c 0) (> d 0))<br>	   (make-interval (* a c) (* b d)))<br>	  ((and (> a 0) (> b 0) (< c 0) (> d 0))<br>	   (make-interval (* b c) (* b d)))<br>	  ((and (< a 0) (> b 0) (> c 0) (> d 0))<br>	   (make-interval (* a d) (* b d)))<br>	  ((and (< a 0) (> b 0) (< c 0) (< d 0))<br>	   (make-interval (* b d) (* a d)))<br>	  ((and (< a 0) (< b 0) (< c 0) (> d 0))<br>	   (make-interval (* b d) (* b c)))<br>	  ((and (< a 0) (< b 0) (< c 0) (< d 0))<br>	   (make-interval (* a c) (* b d)))<br>	  ((or (and (> a 0) (> b 0) (< c 0) (< d 0))<br>	       (and (< a 0) (< b 0) (> c 0) (> d 0)))<br>	   (make-interval (* b d) (* a c)))<br>	  (else (make-interval (min (* a d) (* b c))<br>			       (max (* a c) (* b d)))))))<br>;Value: mul-interval</pre><br><br>Eww. Gross.<br><br><a href="http://sicp.org.ua/sicp/Exercise2-12">2.12</a>:<br><pre lang="scheme"><br>(define (make-center-percent center tolerance)<br>  (make-center-width center (* (/ tolerance 100) center)))<br>;Value: make-center-percent<br><br>(define (percent i)<br> (* (/ (width i) (center i)) 100))<br>;Value: percent<br><br>(percent (make-center-percent 8 5))<br>;Value: 5</pre><br><br>It's not much and I plan on updating and expanding on this but it's done for now.
